<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>第13章——复制模式 · </title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
</span>
<span class="md-header-nav__topic">
第13章——复制模式
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="">
</a>
</label>
<ul>
  <li><a href="../contents.html" class="page">目录</a>
  <ul>
    <li><a href="../abstract.html" class="page">内容提要</a></li>
    <li><a href="../part1.html" class="page">第一部分 简介</a></li>
    <li><a href="../part2.html" class="page">第二部分 微言大义</a></li>
    <li><a href="../part3.html" class="page">第三部分 设计模式</a></li>
    <li><a href="../appendix-01/index.html" class="page">附录A——图解反应式系统</a></li>
    <li><a href="../appendix-02/index.html" class="page">附录B——图解示例</a></li>
    <li><a href="../appendix-03/index.html" class="page">附录C——反应式宣言</a></li>
    <li><a href="../extras.html" class="page">额外指引</a></li>
    <li><a href="../errata.html" class="page">勘误</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../chapter-13/index.html#第13章-复制模式" class="header">第13章——复制模式</a>
  <ul>
    <li><a href="../chapter-13/index.html#13-1-主动-被动复制模式" class="header">13.1 主动-被动复制模式</a></li>
    <li><a href="../chapter-13/index.html#13-2-多主复制模式" class="header">13.2 多主复制模式</a></li>
    <li><a href="../chapter-13/index.html#13-3-主动-主动复制模式" class="header">13.3 主动-主动复制模式</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 1.0.0
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../chapter-13/index.html#第13章-复制模式" class="header">第13章——复制模式</a>
  <ul>
    <li><a href="../chapter-13/index.html#13-1-主动-被动复制模式" class="header">13.1 主动-被动复制模式</a></li>
    <li><a href="../chapter-13/index.html#13-2-多主复制模式" class="header">13.2 多主复制模式</a></li>
    <li><a href="../chapter-13/index.html#13-3-主动-主动复制模式" class="header">13.3 主动-主动复制模式</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#第13章-复制模式" name="第13章-复制模式" class="anchor"><span class="anchor-link"></span></a>第13章——复制模式</h1>
<h2><a href="#13-1-主动-被动复制模式" name="13-1-主动-被动复制模式" class="anchor"><span class="anchor-link"></span></a>13.1 主动-被动复制模式</h2>
<blockquote>
  <p>Protocol</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/KVStoreUtils.scala#L45-L58" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait Command

sealed trait Result

final case class Put(key: String, value: JsValue, replyTo: ActorRef) extends Command

final case class PutConfirmed(key: String, value: JsValue) extends Result

final case class PutRejected(key: String, value: JsValue) extends Result

final case class Get(key: String, replyTo: ActorRef) extends Command

final case class GetResult(key: String, value: Option[JsValue]) extends Result
</code></pre>
<blockquote>
  <p>代码清单 13-1 单例作为主动副本来接管</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L46-L69" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Active(localReplica: ActorRef, replicationFactor: Int, maxQueueSize: Int)
    extends Actor
    with Stash
    with ActorLogging {

  private var theStore: Map[String, JsValue] = _
  private var seqNr: Iterator[Int] = _

  log.info(&quot;taking over from local replica&quot;)
  localReplica ! TakeOver(self)

  def receive: Receive = {
    case InitialState(m, s) =&gt;
      log.info(&quot;took over at sequence {}&quot;, s)
      theStore = m
      seqNr = Iterator.from(s)
      context.become(running)
      unstashAll()
    case _ =&gt; stash()
  }

  val running: Receive = ??? //...
}
</code></pre>
<blockquote>
  <p>代码清单 13-2 主动副本传播复制请求</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L76-L155" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Active(localReplica: ActorRef, replicationFactor: Int, maxQueueSize: Int)
    extends Actor
    with Stash
    with ActorLogging {
  // ...
  private val MaxOutstanding = maxQueueSize / 2

  private var theStore: Map[String, JsValue] = _
  private var seqNr: Iterator[Int] = _
  private val toReplicate = mutable.Queue.empty[Replicate]
  private var replicating = TreeMap.empty[Int, (Replicate, Int)]

  private var rejected = 0

  val timer: Cancellable =
    context.system.scheduler.schedule(1.second, 1.second, self, Tick)(context.dispatcher)

  override def postStop(): Unit = timer.cancel()

  log.info(&quot;taking over from local replica&quot;)
  localReplica ! TakeOver(self)

  def receive: Receive = {
    case InitialState(m, s) =&gt;
      log.info(&quot;took over at sequence {}&quot;, s)
      theStore = m
      seqNr = Iterator.from(s)
      context.become(running)
      unstashAll()
    case _ =&gt; stash()
  }

  val running: Receive = {
    case p @ Put(key, value, replyTo) =&gt;
      if (toReplicate.size &lt; MaxOutstanding) {
        toReplicate.enqueue(Replicate(seqNr.next, key, value, replyTo))
        replicate()
      } else {
        rejected += 1
        replyTo ! PutRejected(key, value)
      }
    case Get(key, replyTo) =&gt;
      replyTo ! GetResult(key, theStore.get(key))
    case Tick =&gt;
      replicating.valuesIterator.foreach {
        case (replicate, _) =&gt; disseminate(replicate)
      }
      if (rejected &gt; 0) {
        log.info(&quot;rejected {} PUT requests&quot;, rejected)
        rejected = 0
      }
    case Replicated(confirm) =&gt;
      replicating.get(confirm) match {
        case None =&gt; // already removed
        case Some((rep, 1)) =&gt;
          replicating -= confirm
          theStore += rep.key -&gt; rep.value
          rep.replyTo ! PutConfirmed(rep.key, rep.value)
        case Some((rep, n)) =&gt;
          replicating += confirm -&gt; (rep, n - 1)
      }
      replicate()
  }

  private def replicate(): Unit =
    if (replicating.size &lt; MaxOutstanding &amp;&amp; toReplicate.nonEmpty) {
      val r = toReplicate.dequeue()
      replicating += r.seq -&gt; (r, replicationFactor)
      disseminate(r)
    }

  private def disseminate(r: Replicate): Unit = {
    val req = r.copy(replyTo = self)
    val members = Cluster(context.system).state.members
    members.foreach(m =&gt; replicaOn(m.address) ! req)
  }

  private def replicaOn(addr: Address): ActorSelection =
    context.actorSelection(localReplica.path.toStringWithAddress(addr))
}</code></pre>
<blockquote>
  <p>代码清单 13-3 通过将JSON文件写入到本地磁盘来实现持久化</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/KVStoreUtils.scala#L11-L39" target="_blank" title="Go to snippet source"></a><code class="language-scala">import java.io.File

import akka.actor.ActorRef
import play.api.libs.json.{ JsValue, Json, OFormat }
import sbt.io.IO

object Persistence {

  final case class Database(seq: Int, kv: Map[String, JsValue])

  object Database {
    implicit val format: OFormat[Database] = Json.format[Database]
  }

  def persist(name: String, seq: Int, kv: Map[String, JsValue]): Unit = {
    val bytes = Json.stringify(Json.toJson(Database(seq, kv)))
    val current = new File(s&quot;./theDataBase-$name.json&quot;)
    val next = new File(s&quot;./theDataBase-$name.json.new&quot;)
    IO.write(next, bytes)
    IO.move(next, current) // atomically update the database
  }

  def readPersisted(name: String): Database = {
    val file = new File(s&quot;theDataBase-$name.json&quot;)
    if (file.exists()) Json.parse(IO.read(file)).as[Database]
    else Database(0, Map.empty)
  }
}
</code></pre>
<blockquote>
  <p>代码清单 13-4 被动副本追踪它们是否是最新的版本</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L168-L216" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Passive(askAroundCount: Int, askAroundInterval: FiniteDuration, maxLag: Int) extends Actor with ActorLogging {

  private val applied = mutable.Queue.empty[Replicate]

  private val name: String =
    Cluster(context.system).selfAddress.toString.replaceAll(&quot;[:/]&quot;, &quot;_&quot;)

  def receive: Receive = readPersisted(name) match {
    case Database(s, kv) =&gt;
      log.info(&quot;started at sequence {}&quot;, s)
      upToDate(kv, s + 1)
  }

  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {
    case TakeOver(active) =&gt;
      log.info(&quot;active replica starting at sequence {}&quot;, expectedSeq)
      active ! InitialState(theStore, expectedSeq)
    case Replicate(s, _, _, replyTo) if s - expectedSeq &lt; 0 =&gt;
      replyTo ! Replicated(s)
    case r: Replicate if r.seq == expectedSeq =&gt;
      val nextStore = theStore + (r.key -&gt; r.value)
      persist(name, expectedSeq, nextStore)
      r.replyTo ! Replicated(r.seq)
      applied.enqueue(r)
      context.become(upToDate(nextStore, expectedSeq + 1))
    case r: Replicate =&gt;
      if (r.seq - expectedSeq &gt; maxLag)
        fallBehind(expectedSeq, TreeMap(r.seq -&gt; r))
      else
        missingSomeUpdates(theStore, expectedSeq, Set.empty, TreeMap(r.seq -&gt; r))
    case GetSingle(s, replyTo) =&gt;
      log.info(&quot;GetSingle from {}&quot;, replyTo)
      if (applied.nonEmpty &amp;&amp; applied.head.seq &lt;= s &amp;&amp; applied.last.seq &gt;= s)
        replyTo ! applied.find(_.seq == s).get
      else if (s &lt; expectedSeq) replyTo ! InitialState(theStore, expectedSeq)
    case GetFull(replyTo) =&gt;
      log.info(&quot;sending full info to {}&quot;, replyTo)
      replyTo ! InitialState(theStore, expectedSeq)
  }

  def fallBehind(expectedSeq: Int, _waiting: TreeMap[Int, Replicate]): Unit = ???

  def missingSomeUpdates(
      theStore: Map[String, JsValue],
      expectedSeq: Int,
      prevOutstanding: Set[Int],
      waiting: TreeMap[Int, Replicate]): Unit = ???
}
</code></pre>
<blockquote>
  <p>代码清单 13-5 被动副本在滞后过多时请求一份全量更新</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L223-L308" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Passive(askAroundCount: Int, askAroundInterval: FiniteDuration, maxLag: Int) extends Actor with ActorLogging {

  private val applied = mutable.Queue.empty[Replicate]
  private var awaitingInitialState = Option.empty[ActorRef]

  private val name: String =
    Cluster(context.system).selfAddress.toString.replaceAll(&quot;[:/]&quot;, &quot;_&quot;)
  private val cluster = Cluster(context.system)
  private val random = new Random

  private var tickTask = Option.empty[Cancellable]

  def scheduleTick(): Unit = {
    tickTask.foreach(_.cancel())
    tickTask = Some(
      context.system.scheduler.scheduleOnce(askAroundInterval, self, DoConsolidate)(context.dispatcher))
  }

  def receive: Receive = readPersisted(name) match {
    case Database(s, kv) =&gt;
      log.info(&quot;started at sequence {}&quot;, s)
      upToDate(kv, s + 1)
  }

  def caughtUp(theStore: Map[String, JsValue], expectedSeq: Int): Unit = {
    awaitingInitialState.foreach(_ ! InitialState(theStore, expectedSeq))
    awaitingInitialState = None
    context.become(upToDate(theStore, expectedSeq))
  }

  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {
    // Cases shown previously elided
    case TakeOver(active)                                   =&gt; ??? //...
    case Replicate(s, _, _, replyTo) if s - expectedSeq &lt; 0 =&gt; ??? //...
    case r: Replicate if r.seq == expectedSeq               =&gt; ??? //...
    case r: Replicate                                       =&gt; ??? //...
    case GetSingle(s, replyTo)                              =&gt; ??? //...
    case GetFull(replyTo) =&gt;
      log.info(&quot;sending full info to {}&quot;, replyTo)
      replyTo ! InitialState(theStore, expectedSeq)
  }

  def fallBehind(expectedSeq: Int, _waiting: TreeMap[Int, Replicate]): Unit = {
    askAroundFullState()
    scheduleTick()
    var waiting = _waiting
    context.become {
      case Replicate(s, _, _, replyTo) if s &lt; expectedSeq =&gt;
        replyTo ! Replicated(s)
      case r: Replicate =&gt;
        waiting += (r.seq -&gt; r)
      case TakeOver(active) =&gt;
        log.info(&quot;delaying active replica takeOver, at seq {} while highest is {}&quot;, expectedSeq, waiting.lastKey)
        awaitingInitialState = Some(active)
      case InitialState(m, s) if s &gt; expectedSeq =&gt;
        log.info(&quot;received newer state at sequence {} (was at {})&quot;, s, expectedSeq)
        persist(name, s, m)
        waiting.to(s).valuesIterator.foreach(r =&gt; r.replyTo ! Replicated(r.seq))
        val nextWaiting = waiting.from(expectedSeq)
        consolidate(m, s + 1, Set.empty, nextWaiting)
      case DoConsolidate =&gt;
        askAroundFullState()
        scheduleTick()
    }
  }

  private def consolidate(
      theStore: Map[String, JsValue],
      expectedSeq: Int,
      askedFor: Set[Int],
      waiting: TreeMap[Int, Replicate]): Unit = ??? //...

  private def getMembers(n: Int): Seq[Address] = {
    // using .iterator to avoid one intermediate collection to be created
    random.shuffle(cluster.state.members.iterator.map(_.address).toSeq).take(n)
  }

  private def askAroundFullState(): Unit = {
    log.info(&quot;asking for full data&quot;)
    getMembers(1).foreach(addr =&gt; replicaOn(addr) ! GetFull(self))
  }

  private def replicaOn(addr: Address): ActorSelection =
    context.actorSelection(self.path.toStringWithAddress(addr))
}
</code></pre>
<blockquote>
  <p>代码清单 13-6 计算直接可应用的队列前段的长度</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L334-L364" target="_blank" title="Go to snippet source"></a><code class="language-scala">private val matches = (p: (Int, Int)) =&gt; p._1 == p._2

private def consolidate(
    theStore: Map[String, JsValue],
    expectedSeq: Int,
    askedFor: Set[Int],
    waiting: TreeMap[Int, Replicate]): Unit = {

  // calculate applicable prefix length
  val prefix = waiting.keysIterator.zip(Iterator.from(expectedSeq)).takeWhile(matches).size

  val nextStore = waiting.valuesIterator.take(prefix).foldLeft(theStore) { (store, replicate) =&gt;
    persist(name, replicate.seq, theStore)
    replicate.replyTo ! Replicated(replicate.seq)
    applied.enqueue(replicate)
    store + (replicate.key -&gt; replicate.value)
  }
  val nextWaiting = waiting.drop(prefix)
  val nextExpectedSeq = expectedSeq + prefix

  // cap the size of the applied buffer
  applied.drop(Math.max(0, applied.size - maxLag))

  if (nextWaiting.nonEmpty) {
    // check if we fell behind by too much
    if (nextWaiting.lastKey - nextExpectedSeq &gt; maxLag)
      fallBehind(nextExpectedSeq, nextWaiting)
    else missingSomeUpdates(nextStore, nextExpectedSeq, askedFor, nextWaiting)
  } else caughtUp(nextStore, nextExpectedSeq)
}
</code></pre>
<blockquote>
  <p>代码清单 13-7 确定更新队列里的数据缺口是否可以被一一填补</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActivePassive.scala#L384-L472" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Passive(askAroundCount: Int, askAroundInterval: FiniteDuration, maxLag: Int) extends Actor with ActorLogging {

  private val applied = mutable.Queue.empty[Replicate]
  private var awaitingInitialState = Option.empty[ActorRef]

  // ... Initialization elided
  def receive: Receive = ??? //...

  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {
    case TakeOver(active)                                   =&gt; ??? //...
    case Replicate(s, _, _, replyTo) if s - expectedSeq &lt; 0 =&gt; ??? //...
    case r: Replicate if r.seq == expectedSeq               =&gt; ??? //...
    case r: Replicate                                       =&gt; ??? //...
    case GetFull(replyTo)                                   =&gt; ??? //...
    case GetSingle(s, replyTo) =&gt;
      log.info(&quot;GetSingle from {}&quot;, replyTo)
      if (applied.nonEmpty &amp;&amp;
          applied.head.seq &lt;= s &amp;&amp; applied.last.seq &gt;= s) {
        replyTo ! applied.find(_.seq == s).get
      } else if (s &lt; expectedSeq) {
        replyTo ! InitialState(theStore, expectedSeq)
      }
  }

  def missingSomeUpdates(
      theStore: Map[String, JsValue],
      expectedSeq: Int,
      prevOutstanding: Set[Int],
      waiting: TreeMap[Int, Replicate]): Unit = {

    val askFor = (expectedSeq to waiting.lastKey).iterator
      .filterNot(seq =&gt;
        waiting.contains(seq) ||
        prevOutstanding.contains(seq))
      .toList

    askFor.foreach(askAround)

    if (prevOutstanding.isEmpty) {
      scheduleTick()
    }
    val outstanding = prevOutstanding ++ askFor

    context.become {
      case Replicate(s, _, _, replyTo) if s &lt; expectedSeq =&gt;
        replyTo ! Replicated(s)
      case r: Replicate =&gt;
        consolidate(theStore, expectedSeq, outstanding - r.seq, waiting + (r.seq -&gt; r))
      case TakeOver(active) =&gt;
        log.info(&quot;delaying active replica takeOver, at seq {} while highest is {}&quot;, expectedSeq, waiting.lastKey)
        awaitingInitialState = Some(active)
      case GetSingle(s, replyTo) =&gt;
        log.info(&quot;GetSingle from {}&quot;, replyTo)
        if (applied.nonEmpty &amp;&amp;
            applied.head.seq &lt;= s &amp;&amp;
            applied.last.seq &gt;= s) {
          replyTo ! applied.find(_.seq == s).get
        } else if (s &lt; expectedSeq) {
          replyTo ! InitialState(theStore, expectedSeq)
        }
      case GetFull(replyTo) =&gt;
        log.info(&quot;sending full info to {}&quot;, replyTo)
        replyTo ! InitialState(theStore, expectedSeq)
      case DoConsolidate =&gt;
        outstanding.foreach(askAround)
        scheduleTick()
    }
  }

  private def askAround(seq: Int): Unit = {
    log.info(&quot;asking around for sequence number {}&quot;, seq)
    getMembers(askAroundCount).foreach(addr =&gt; replicaOn(addr) ! GetSingle(seq, self))
  }

  // ... Other helpers elided
  private def consolidate(
      theStore: Map[String, JsValue],
      expectedSeq: Int,
      askedFor: Set[Int],
      waiting: TreeMap[Int, Replicate]): Unit = ???

  private def getMembers(n: Int): Seq[Address] = ???

  private def replicaOn(addr: Address): ActorSelection = ???

  def scheduleTick(): Unit = ???

}
</code></pre>
<h2><a href="#13-2-多主复制模式" name="13-2-多主复制模式" class="anchor"><span class="anchor-link"></span></a>13.2 多主复制模式</h2>
<blockquote>
  <p>代码清单 13-8 使用 CKite 来实现键值存储</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/ckite/KVStore.scala#L26-L51" target="_blank" title="Go to snippet source"></a><code class="language-scala">class KVStore extends StateMachine {
  private var map = mutable.Map[String, String]()
  private var lastIndex: Long = 0

  def applyWrite: PartialFunction[(Long, WriteCommand[_]), String] = {
    case (index, Put(key: String, value: String)) =&gt;
      map.put(key, value)
      lastIndex = index
      value
  }

  def applyRead: PartialFunction[ReadCommand[_], Option[String]] = {
    case Get(key) =&gt; map.get(key)
  }

  def getLastAppliedIndex: Long = lastIndex

  def restoreSnapshot(byteBuffer: ByteBuffer): Unit = {
    map = Serializer.deserialize[mutable.Map[String, String]](byteBuffer.array())
  }

  def takeSnapshot(): ByteBuffer =
    ByteBuffer.wrap(Serializer.serialize(map))

}
</code></pre>
<blockquote>
  <p>代码清单 13-9 按照复制状态机来实例化KVStore</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/ckite/KVStore.scala#L55-L62" target="_blank" title="Go to snippet source"></a><code class="language-scala">object KVStoreBootstrap extends App {
  val ckite =
    CKiteBuilder().stateMachine(new KVStore()).rpc(FinagleThriftRpc).storage(MapDBStorage()).build
  ckite.start()

  HttpServer(ckite).start()
}
</code></pre>
<blockquote>
  <p>ckite api</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/ckite/KVStore.scala#L72-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">val consistentRead: Future[Option[String]] = ckite.read(Get(key))
val possibleStaleRead: Future[Option[String]] = ckite.readLocal(Get(key))
val write: Future[String] = ckite.write(Put(key, value))</code></pre>
<blockquote>
  <p>代码清单 13-10 图13-1中图形的代码表示</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/MultiMasterCRDT.scala#L20-L43" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class Status(name: String)(_predecessor: =&gt; Set[Status], _successor: =&gt; Set[Status])
    extends ReplicatedData {

  type T = Status

  def merge(that: Status): Status = mergeStatus(this, that)

  @volatile lazy val predecessors: Set[Status] = _predecessor
  @volatile lazy val successors: Set[Status] = _successor

}

val New: Status =
  Status(&quot;new&quot;)(Set.empty, Set(Scheduled, Cancelled))
val Scheduled: Status =
  Status(&quot;scheduled&quot;)(Set(New), Set(Executing, Cancelled))
val Executing: Status =
  Status(&quot;executing&quot;)(Set(Scheduled), Set(Aborted, Finished))
val Finished: Status =
  Status(&quot;finished&quot;)(Set(Executing, Aborted), Set.empty)
val Cancelled: Status =
  Status(&quot;cancelled&quot;)(Set(New, Scheduled), Set(Aborted))
val Aborted: Status =
  Status(&quot;aborted&quot;)(Set(Cancelled, Executing), Set(Finished))</code></pre>
<blockquote>
  <p>代码清单 13-11 合并两个状态来产生第三个合并后的状态</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/MultiMasterCRDT.scala#L47-L73" target="_blank" title="Go to snippet source"></a><code class="language-scala">def mergeStatus(left: Status, right: Status): Status = {
  /*
   * Keep the left Status in hand and determine whether it is a predecessor of
   * the candidate, moving on to the candidate’s successor if not successful.
   * The list of exclusions is used to avoid performing already determined
   * unsuccessful comparisons again.
   */
  def innerLoop(candidate: Status, exclude: Set[Status]): Status =
    if (isSuccessor(candidate, left, exclude)) {
      candidate
    } else {
      val nextExclude = exclude + candidate
      val branches =
        candidate.successors.map(successor =&gt; innerLoop(successor, nextExclude))
      branches.reduce((l, r) =&gt; if (isSuccessor(l, r, nextExclude)) r else l)
    }

  def isSuccessor(candidate: Status, fixed: Status, exclude: Set[Status]): Boolean =
    if (candidate == fixed) true
    else {
      val toSearch = candidate.predecessors -- exclude
      toSearch.exists(pred =&gt; isSuccessor(pred, fixed, exclude))
    }

  innerLoop(right, Set.empty)
}
</code></pre>
<blockquote>
  <p>代码清单 13-12 使用 Akka Distributed Data 来传播状态变更</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/MultiMasterCRDT.scala#L89-L116" target="_blank" title="Go to snippet source"></a><code class="language-scala">class ClientInterface extends Actor with ActorLogging {
  private val replicator: ActorRef = DistributedData(context.system).replicator
  private implicit val cluster: Cluster = Cluster(context.system)

  def receive: Receive = {
    case Submit(job) =&gt;
      log.info(&quot;submitting job {}&quot;, job)
      replicator ! Replicator.Update(
        StorageComponent,
        ORMap.empty[String, Status],
        Replicator.WriteMajority(5.seconds),
        Some(s&quot;submit $job&quot;))(_ + (job -&gt; New))
    case Cancel(job) =&gt;
      log.info(&quot;cancelling job {}&quot;, job)
      replicator ! Replicator.Update(
        StorageComponent,
        ORMap.empty[String, Status],
        Replicator.WriteMajority(5.seconds),
        Some(s&quot;cancel $job&quot;))(_ + (job -&gt; Cancelled))
    case r: Replicator.UpdateResponse[_] =&gt;
      log.info(&quot;received update result: {}&quot;, r)
    case PrintStatus =&gt;
      replicator ! Replicator.Get(StorageComponent, Replicator.ReadMajority(5.seconds))
    case g: Replicator.GetSuccess[_] =&gt;
      log.info(&quot;overall status: {}&quot;, g.get(StorageComponent))
  }
}
</code></pre>
<blockquote>
  <p>代码清单 13-13 引入对于任务的请求标志</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/MultiMasterCRDT.scala#L120-L161" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Executor extends Actor with ActorLogging {
  private val replicator: ActorRef = DistributedData(context.system).replicator
  private implicit val cluster: Cluster = Cluster(context.system)

  private var lastState = Map.empty[String, Status]

  replicator ! Replicator.Subscribe(StorageComponent, self)

  def receive: Receive = {
    case Execute(job) =&gt;
      log.info(&quot;executing job {}&quot;, job)
      replicator ! Replicator.Update(
        StorageComponent,
        ORMap.empty[String, Status],
        Replicator.WriteMajority(5.seconds),
        Some(job)) { map =&gt;
        require(map.get(job).contains(New))
        map + (job -&gt; Executing)
      }
    case Finish(job) =&gt;
      log.info(&quot;job {} finished&quot;, job)
      replicator ! Replicator.Update(
        StorageComponent,
        ORMap.empty[String, Status],
        Replicator.WriteMajority(5.seconds))(_ + (job -&gt; Finished))
    case Replicator.UpdateSuccess(StorageComponent, Some(job)) =&gt;
      log.info(&quot;starting job {}&quot;, job)
    case r: Replicator.UpdateResponse[_] =&gt;
      log.info(&quot;received update result: {}&quot;, r)
    case ch: Replicator.Changed[_] =&gt;
      val current = ch.get(StorageComponent).entries
      for {
        (job, status) &lt;- current.iterator
        if status == Aborted
        if !lastState.get(job).contains(Aborted)
      } {
        log.info(&quot;aborting job {}&quot;, job)
        lastState = current
      }
  }
}
</code></pre>
<h2><a href="#13-3-主动-主动复制模式" name="13-3-主动-主动复制模式" class="anchor"><span class="anchor-link"></span></a>13.3 主动-主动复制模式</h2>
<blockquote>
  <p>代码清单 13-14 用无协调工作的实现来开始主动-主动复制模式</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L22-L54" target="_blank" title="Go to snippet source"></a><code class="language-scala">private final case class SeqCommand(seq: Int, cmd: Command, replyTo: ActorRef)

private final case class SeqResult(seq: Int, res: Result, replica: ActorRef, replyTo: ActorRef)

private final case class SendInitialData(toReplica: ActorRef)

private final case class InitialData(map: Map[String, JsValue])

class Replica extends Actor with Stash {
  private var map = Map.empty[String, JsValue]

  def receive: Receive = {
    case InitialData(m) =&gt;
      map = m
      context.become(initialized)
      unstashAll()
    case _ =&gt; stash()
  }

  def initialized: Receive = {
    case SeqCommand(seq, cmd, replyTo) =&gt;
      // tracking of sequence numbers and resents is elided here
      cmd match {
        case Put(key, value, r) =&gt;
          map += key -&gt; value
          replyTo ! SeqResult(seq, PutConfirmed(key, value), self, r)
        case Get(key, r) =&gt;
          replyTo ! SeqResult(seq, GetResult(key, map.get(key)), self, r)
      }
    case SendInitialData(toReplica) =&gt; toReplica ! InitialData(map)
  }
}
</code></pre>
<blockquote>
  <p>代码清单 13-15 封装对于单个客户端请求的知悉情况</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L62-L122" target="_blank" title="Go to snippet source"></a><code class="language-scala">private sealed trait ReplyState {
  def deadline: Deadline

  def missing: Set[ActorRef]

  def add(res: SeqResult): ReplyState

  def isFinished: Boolean = missing.isEmpty
}

private final case class Unknown(deadline: Deadline, replies: Set[SeqResult], missing: Set[ActorRef], quorum: Int)
    extends ReplyState {

  override def add(res: SeqResult): ReplyState = {
    val nextReplies = replies + res
    val nextMissing = missing - res.replica
    if (nextReplies.size &gt;= quorum) {
      val answer =
        replies.toSeq.groupBy(_.res).collectFirst {
          case (k, s) if s.size &gt;= quorum =&gt; s.head
        }

      if (answer.isDefined) {
        val right = answer.get
        val wrong = replies.collect {
          case SeqResult(_, result, replica, _) if res != right =&gt; replica
        }
        Known(deadline, right, wrong, nextMissing)
      } else if (nextMissing.isEmpty) {
        Known.fromUnknown(deadline, nextReplies)
      } else Unknown(deadline, nextReplies, nextMissing, quorum)
    } else Unknown(deadline, nextReplies, nextMissing, quorum)
  }
}

private final case class Known(deadline: Deadline, reply: SeqResult, wrong: Set[ActorRef], missing: Set[ActorRef])
    extends ReplyState {

  override def add(res: SeqResult): ReplyState = {
    val nextWrong =
      if (res.res == reply.res)
        wrong
      else
        wrong + res.replica
    Known(deadline, reply, nextWrong, missing - res.replica)
  }
}

private object Known {
  def fromUnknown(deadline: Deadline, replies: Set[SeqResult]): Known = {
    // did not reach consensus on this one, pick simple majority
    val counts = replies.groupBy(_.res)
    val biggest = counts.iterator.map(_._2.size).max
    val winners = counts.collectFirst {
      case (res, win) if win.size == biggest =&gt; win
    }.get
    val losers = (replies -- winners).map(_.replica)
    Known(deadline, winners.head, losers, Set.empty)
  }
}
</code></pre>
<blockquote>
  <p>代码清单 13-16 将副本当作子Actor管理</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L126-L213" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Coordinator(N: Int) extends Actor {
  private var replicas = (1 to N).map(_ =&gt; newReplica()).toSet
  private val seqNr = Iterator.from(0)
  private var replies = TreeMap.empty[Int, ReplyState]
  private var nextReply = 0

  override def supervisorStrategy: SupervisorStrategy =
    SupervisorStrategy.stoppingStrategy

  private def newReplica(): ActorRef =
    context.watch(context.actorOf(Replica.props))

  // schedule timeout messages for quiescent periods
  context.setReceiveTimeout(1.second)

  def receive: Receive =
    ({
      case cmd: Command =&gt;
        val c = SeqCommand(seqNr.next, cmd, self)
        replicas.foreach(_ ! c)
        replies += c.seq -&gt; Unknown(5.seconds(fromNow), Set.empty, replicas, (replicas.size + 1) / 2)
      case res: SeqResult
          if replies.contains(res.seq) &amp;&amp;
          replicas.contains(res.replica) =&gt;
        val prevState = replies(res.seq)
        val nextState = prevState.add(res)
        replies += res.seq -&gt; nextState
      case Terminated(ref) =&gt;
        replaceReplica(ref, terminate = false)
      case ReceiveTimeout =&gt;
    }: Receive).andThen { _ =&gt;
      doTimeouts()
      sendReplies()
      evictFinished()
    }

  //...
  private def doTimeouts(): Unit = {
    val now = Deadline.now
    val expired = replies.iterator.takeWhile(_._2.deadline &lt;= now)
    for ((seq, state) &lt;- expired) {
      state match {
        case Unknown(deadline, received, _, _) =&gt;
          val forced = Known.fromUnknown(deadline, received)
          replies += seq -&gt; forced
        case Known(deadline, reply, wrong, missing) =&gt;
          replies += seq -&gt; Known(deadline, reply, wrong, Set.empty)
      }
    }
  }


  @tailrec private def sendReplies(): Unit =
    replies.get(nextReply) match {
      case Some(k @ Known(_, reply, _, _)) =&gt;
        reply.replyTo ! reply.res
        nextReply += 1
        sendReplies()
      case _ =&gt;
    }


  @tailrec private def evictFinished(): Unit =
    replies.headOption match {
      case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished =&gt;
        wrong.foreach(replaceReplica(_, terminate = true))
        replies -= seq
        evictFinished()
      case _ =&gt;
    }

  private def replaceReplica(r: ActorRef, terminate: Boolean): Unit =
    if (replicas contains r) {
      replicas -= r
      if (terminate) r ! PoisonPill
      val replica = newReplica()
      replicas.head ! SendInitialData(replica)
      replicas += replica
    }

}
</code></pre>
<blockquote>
  <p>代码清单 13-17 按序发送回复</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L181-L189" target="_blank" title="Go to snippet source"></a><code class="language-scala">@tailrec private def sendReplies(): Unit =
  replies.get(nextReply) match {
    case Some(k @ Known(_, reply, _, _)) =&gt;
      reply.replyTo ! reply.res
      nextReply += 1
      sendReplies()
    case _ =&gt;
  }
</code></pre>
<blockquote>
  <p>代码清单 13-18 一旦timeout，就强迫将“missing”回复转为“known”回复</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L164-L177" target="_blank" title="Go to snippet source"></a><code class="language-scala">private def doTimeouts(): Unit = {
  val now = Deadline.now
  val expired = replies.iterator.takeWhile(_._2.deadline &lt;= now)
  for ((seq, state) &lt;- expired) {
    state match {
      case Unknown(deadline, received, _, _) =&gt;
        val forced = Known.fromUnknown(deadline, received)
        replies += seq -&gt; forced
      case Known(deadline, reply, wrong, missing) =&gt;
        replies += seq -&gt; Known(deadline, reply, wrong, Set.empty)
    }
  }
}
</code></pre>
<blockquote>
  <p>代码清单 13-19 终止并替换未完成的副本</p>
</blockquote>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/chapter13/src/main/scala/chapter13/ActiveActive.scala#L193-L210" target="_blank" title="Go to snippet source"></a><code class="language-scala">@tailrec private def evictFinished(): Unit =
  replies.headOption match {
    case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished =&gt;
      wrong.foreach(replaceReplica(_, terminate = true))
      replies -= seq
      evictFinished()
    case _ =&gt;
  }

private def replaceReplica(r: ActorRef, terminate: Boolean): Unit =
  if (replicas contains r) {
    replicas -= r
    if (terminate) r ! PoisonPill
    val replica = newReplica()
    replicas.head ! SendInitialData(replica)
    replicas += replica
  }
</code></pre>
</div>
<div>
<a href="https://github.com/ReactivePlatform/Reactive-Design-Patterns/tree/v1.0.0/docs/src/paradox/chapter-13/index.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
1.0.0
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../chapter-12/index.html" title="第12章——容错及恢复模式" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
第12章——容错及恢复模式
</span>
</div>
</a>
<a href="../chapter-14/index.html" title="第14章——资源管理模式" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
第14章——资源管理模式
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
