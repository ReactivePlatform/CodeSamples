{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"《反应式设计模式》\nRoland Kuhn with Brian Hanafee and Jamie Allen 著\n何品 邱嘉和 王石冲 译\n林炜翔 校审\n定义未来十年的分布式系统架构！ 在线购买： 京东 当当\n目录 内容提要 第一部分 简介 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业工具 第二部分 微言大义 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——原则性失败处理 第8章——有界一致性 第9章——按需使用非确定性 第10章——消息流 第三部分 设计模式 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言 额外指引 勘误 全书代码清单更新 译者序1 第一章 第二章 第三章 第三章 第三章 第三章 第三章 第四章 第十一章 第十三章 第十四章","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"《反应式设计模式》\nRoland Kuhn with Brian Hanafee and Jamie Allen 著\n何品 邱嘉和 王石冲 译\n林炜翔 校审\n定义未来十年的分布式系统架构！ 在线购买： 京东 当当","title":"目录"},{"location":"/abstract.html","text":"","title":"内容提要 ·"},{"location":"/abstract.html#内容提要","text":"本书旨在成为引导你理解和设计反应式系统的综合性指南，因此，它不仅提供了《反应式宣言》的注解版本，还包括了开创该宣言的缘由和论据。本书浓墨重彩地描述一些反应式设计模式，这些模式实现反应式系统设计的多个方面；还列出了更深层次的文献资源，以便你对其进行进一步的研究。所陈述的模式形成一个连贯整体，虽然并非详尽无遗，但其所包含的背景知识将使得读者能在需要的时候识别、提炼和呈现出新模式。","title":"内容提要"},{"location":"/part1.html","text":"","title":"第一部分 简介 ·"},{"location":"/part1.html#第一部分-简介","text":"你有曾思考过高性能Web应用程序是如何实现的吗？社交网络和大型零售网站肯定有一些秘密配方使得系统运行迅速并且可靠，但这些秘密是什么呢？在这本书中，我们将为你揭晓谜底，你将学习到这些近似永远不出故障，并且能够满足数十亿人需要的系统背后的设计原则与模式。虽然你所构建的系统未必有如此雄心壮志的要求，但是它们主要的特质应该是一致的：\n你想要你的应用程序可靠地工作，即使某些部件（硬件或者软件）有可能出现故障。\n你希望你的应用程序在你需要支撑更多的用户时，可以持续地提供服务，而且你希望能够通过添加或者删除资源来调整它的能力，从而适应不断变化的需求（没有可以预测未来的水晶球的帮助，很难进行正确的容量规划）。\n在第1章中，我们将勾勒出一个具备这些特质的应用程序的开发过程。我们将指明你会遇到的挑战，并基于一个具体的例子（一个假想中的Gmail服务实现）给出解决方案，但是我们将会以不提供具体的技术选型的形式进行。\n这个使用场景为接下来在第2章中对《反应式宣言》所进行的详细讨论作了铺垫。该宣言以简洁、抽象的形式撰写，目的是为了聚焦于它的本质：将多个独立的、有效的程序特性凝聚为一个整体，从而形成更大的合力。我们将通过把高度抽象的特质分解为更小的部分，并解释各部分又是如何合回一体的过程，来展现这一点。\n我们将会以第3章结束这一部分，其大致地介绍了行业工具：函数式编程、Future 和 Promise、通信顺序进程（CSP）、 Observer 和 Observable（Reactive Extensions）以及 Actor 模型。","title":"第一部分 简介"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"我们的初心，是构建一个对用户即时响应的（responsive）系统。这意味着该系统无论在什么样的情况下，都应该能即时响应用户的输入。由于任何单台计算机在任何时刻都有可能宕机，所以我们需要将这一个系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。在过去，我们建立了各种方法来允许我们维持某种假像：单线程的本地运算能够魔法般地扩展运行在多个处理器核心或者网络节点上。然而，这虚实之间的沟壑已经大到难以为继。而解决之法是让我们的应用程序中所具有的分布和并发的本质明明白白地反映到编程模型上来，并使它变成我们的优势。\n没有代码清单","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"这一章详细地介绍了《反应式宣言》：原文文字简练且内容紧凑，我们将在这里加以展开并进行深入地讨论。有关该宣言相关理论的更多背景知识，请参阅本书第二部分。","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#2-1-对用户作出反应","text":"代码清单 2-1 图片服务中简单 Controller 的一段代码\npublic interface Images {\n  Image get(String key);\n\n  void add(String key, Image image);\n}\n\nprivate Images cache;\nprivate Images database;\n\npublic Image retrieveImages(String key) {\n  Image result = cache.get(key);\n  if (result != null) {\n    return result;\n  } else {\n    result = database.get(key);\n    if (result != null) {\n      cache.add(key, result);\n      return result;\n    } else {\n      return FALLBACK;\n    }\n  }\n}","title":"2.1 对用户作出反应"},{"location":"/chapter-02/index.html#2-2-利用并行性","text":"SimpleFunction.scala\nval result = f(42)\nSequentialExecution.java\nfinal ReplyA a = computeA();\nfinal ReplyB b = computeB();\nfinal ReplyC c = computeC();\n\nfinal Result r = aggregate(a, b, c);\nParallelExecutionWithJavaFuture.java\nfinal Future<ReplyA> a = taskA();\nfinal Future<ReplyB> b = taskB();\nfinal Future<ReplyC> c = taskC();\n\nfinal Result r = aggregate(a.get(), b.get(), c.get());\nParallelExecutionWithScalaFuture.scala\nval fa: Future[ReplyA] = taskA()\nval fb: Future[ReplyB] = taskB()\nval fc: Future[ReplyC] = taskC()\n\nval fr: Future[Result] = for (a ← fa; b ← fb; c ← fc)\n  yield aggregate(a, b, c)\nBlockingSocketRead.java\nfinal Socket socket = new Socket(\"127.0.0.1\", 8080);\nsocket.getOutputStream().write(requestMessageBytes);\nfinal int bytesRead = socket.getInputStream().read(responseBuffer);\nAskActorWithJava8.java\nfinal CompletionStage<Response> future =\n    ask(actorRef, request, timeout).thenApply(Response.class::cast);\nfuture.thenAccept(AskActorWithJava8::processIt);","title":"2.2 利用并行性"},{"location":"/chapter-02/index.html#2-4-对失败作出反应","text":"ExceptionHandler.scala\ntry {\n  f(i)\n} catch {\n  case _: java.lang.ArithmeticException ⇒ Int.MaxValue\n  case ex: java.lang.StackOverflowError ⇒ ???\n  case ex: java.net.ConnectException    ⇒ ???\n}","title":"2.4 对失败作出反应"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业工具 ·"},{"location":"/chapter-03/index.html#第3章-行业工具","text":"","title":"第3章——行业工具"},{"location":"/chapter-03/index.html#3-2-函数式编程","text":"代码清单3-1 不安全的、可变的消息类，可能会隐含非预期的行为\nimport java.util.Date;\n\npublic class Unsafe {\n  private Date timestamp;\n  private final StringBuffer message;\n\n  public Unsafe(Date timestamp, StringBuffer message) {\n    this.timestamp = timestamp;\n    this.message = message;\n  }\n\n  public synchronized Date getTimestamp() {\n    return timestamp;\n  }\n\n  public synchronized void setTimestamp(Date timestamp) {\n    this.timestamp = timestamp;\n  }\n\n  public StringBuffer getMessage() {\n    return message;\n  }\n}\n代码清单 3-2 不可变的消息类，其行为是可预知的，并易于推断\nimport java.util.Date;\n\npublic class Immutable {\n  private final Date timestamp;\n  private final String message;\n\n  public Immutable(final Date timestamp, final String message) {\n    this.timestamp = new Date(timestamp.getTime());\n    this.message = message;\n  }\n\n  public Date getTimestamp() {\n    return new Date(timestamp.getTime());\n  }\n\n  public String getMessage() {\n    return message;\n  }\n}\nMessage.scala\nimport java.util.Date\n\nfinal case class Message(timestamp: Date, message: String)\nUsingStringBuffer.java\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\"original '%s', new value '%s'\", original, reversed));\n代码清单 3-3 引用透明性：允许代换预先计算好的值\npublic class Rooter {\n  private final double value;\n  private Double root = null;\n\n  public Rooter(double value) {\n    this.value = value;\n  }\n\n  public double getValue() {\n    return value;\n  }\n\n  public double getRoot() {\n    if (root == null) {\n      root = Math.sqrt(value);\n    }\n    return root;\n  }\n}\n代码清单3-4 因副作用而受限的可用性\npublic class SideEffecting implements Serializable, Cloneable {\n  private int count;\n\n  public SideEffecting(int start) {\n    this.count = start;\n  }\n\n  public int next() {\n    this.count += Math.incrementExact(this.count);\n    return this.count;\n  }\n}\nIntSeeding.java\nfinal int next = se.next();\nif (logger.isDebugEnabled()) {\n  logger.debug(\"Next is \" + se.next());\n}\nreturn next;\nUsingMapFunction.java\nfinal List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n    numbers.stream().map(number -> number + 1).collect(Collectors.toList());\nPython REPL\n>>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"3.2 函数式编程"},{"location":"/chapter-03/index.html#3-4-对反应式设计的现有支持","text":"sample.js\nvar http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n    counter++;\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');\nsample.go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\titerations := 10\n\tmyChannel := make(chan int)\n\n\tgo producer(myChannel, iterations)\n\tgo consumer(myChannel, iterations)\n\n\ttime.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n\tfor i := 1; i <= iterations; i++ {\n\t\tfmt.Println(\"Sending: \", i)\n\t\tmyChannel <- i\n\t}\n}\n\nfunc consumer(myChannel chan int, iterations int) {\n\tfor i := 1; i <= iterations; i++ {\n\t\trecVal := <-myChannel\n\t\tfmt.Println(\"Received: \", recVal)\n\t}\n}\n代码清单3-5 从更快的数据源获取结果\npublic class ParallelRetrievalExample {\n  private final CacheRetriever cacheRetriever;\n  private final DBRetriever dbRetriever;\n\n  ParallelRetrievalExample(CacheRetriever cacheRetriever, DBRetriever dbRetriever) {\n    this.cacheRetriever = cacheRetriever;\n    this.dbRetriever = dbRetriever;\n  }\n\n  public Object retrieveCustomer(final long id) {\n    final CompletableFuture<Object> cacheFuture =\n        CompletableFuture.supplyAsync(() -> cacheRetriever.getCustomer(id));\n    final CompletableFuture<Object> dbFuture =\n        CompletableFuture.supplyAsync(() -> dbRetriever.getCustomer(id));\n\n    return CompletableFuture.anyOf(cacheFuture, dbFuture);\n  }\n}\n代码清单3-6 使用Scala编程语言将两个Future的结果组合为单一结果\n// Provide the thread pool to be applied\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutor(\n  ForkJoinPool.commonPool())\n\ndef getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}\nStagedFuturesAsyncExample.scala\nimport scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}\nRxJavaExample.java\npackage chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n  public void observe(String[] strings) {\n    Observable.fromArray(strings).subscribe((s) -> System.out.println(\"Received \" + s));\n  }\n}\nRxJavaExampleDriver.java\npackage chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n  private static final RxJavaExample RX_JAVA_EXAMPLE = new RxJavaExample();\n\n  public static void main(String[] args) {\n    String[] strings = {\"a\", \"b\", \"c\"};\n    RX_JAVA_EXAMPLE.observe(strings);\n  }\n}\n代码清单3-7 一个使用 Akka 的Actor的例子\npackage chapter03.actor\n\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.actor._\nimport akka.event.LoggingReceive\n\ncase object Start\n\nfinal case class CounterMessage(counterValue: Int)\n\nfinal case class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: Receive = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: Receive = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"3.4 对反应式设计的现有支持"},{"location":"/part2.html","text":"","title":"第二部分 微言大义 ·"},{"location":"/part2.html#第二部分-微言大义","text":"这本书的第一部分综述了反应式系统的价值。你看到了对用户输入总是保持回弹性和可伸缩性的需要，从而即使在失败和不同负载的情况下也能保持即时响应性。在我们探索这些可取的属性过程中，你得出了需要使用消息驱动来作为底层实现的必要性。\n第二部分对反应式的 4 个特质进行了补充说明：提出了一组构建反应式架构的构建块。这一部分的重点是如何做到反应式，而第一部分则描述了我们要实现的目标及缘由。在这一部分所讨论的指导原则，以及我们在第3章中所介绍的行业工具，一起构成了第三部分中多种模式的基础。\n我们决定以一种连贯、凝聚的方式组织这些材料，以便你在构建反应式应用程序的过程中，推敲你自己的模式设计时，本书可以方便地作为一个紧凑的参考。作为一个完整的反应式架构的360度全景，这一部分涵盖了大量的基础理论。你可能想要先阅读第4章，然后略读这一部分的其余章节，并在你研究这本书第三部分中所介绍的相应模式时，再回过头来细细研读这部分中的对应章节。\n在这一部分中，你将学习到：\n通过显式的异步消息传递来使得封装和隔离成为可能； 通过位置透明性，提高组合能力，并添加水平扩展能力； 应用分而治之（divide et regna），以层级化模块的形式组织系统； 这个层级结构如何使得原则化的失败处理成为可能； 在分布式系统中实现足够一致的程序语义； 尽可能地避免不确定性，并在必要时添加； 使用基于消息流的拓扑指导反应式应用程序设计。","title":"第二部分 微言大义"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"事件，是建立消息传递的基石：事实上，一个特定条件的触发（事件本身）捆绑了上下文信息——如某人在某时某地做了某事——并且被生产者以消息的形式传送。而感兴趣的各方则可以通过一个共同的传输机制得知并消费该消息。\n没有代码清单","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"前面的章节介绍了消息传递作为解耦协作对象的一种方式。将通信变为异步、非阻塞的，而不是调用同步方法，这使得接收者能够在不同的执行上下文（比如不同的线程）中执行其工作。但为什么要止步于一台机器内的交互呢？消息传递在本地和远程交互中的工作原理相同。调度一个任务在本地机器上稍后运行，与发送一个网络包到不同的主机并在那里触发执行，并没有本质的区别。在这一章中，我们将探讨这个视角所提供的可能性，以及它对诸如延迟、吞吐量和消息丢失的概率等性能量化指标的影响。\n没有代码清单","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"上一章假定程序通常由多个组件构成，这些组件以某种方式分离：由不同的团队开发不同的功能领域；通过接口访问模块；模块被打包成容易被替换的方式；等等。在过去的几十年间，我们花费了大量的精力在编程语言中定义模块的语法和语义上，以及用于部署他们的库和基础设施。重要的问题是，我们应该如何划分一个问题，从而成功地解决它呢？\n本章无代码清单","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——原则性失败处理 ·"},{"location":"/chapter-07/index.html#第7章-原则性失败处理","text":"你已经知道回弹性要求对系统进行分布和划分。分布式是唯一可以避免因单点故障（无论是硬件、软件或者人为失误）而导致全局失败的方式；划分可以隔离不同的分布式单元，使得任意单元的失败都不会扩散到其他单元上。总而言之，为了在失败之后恢复正常的功能，你需要将对失败作出反应的职责委托给一个监督者（supervisor）。\n没有代码清单","title":"第7章——原则性失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有界一致性 ·"},{"location":"/chapter-08/index.html#第8章-有界一致性","text":"分布式系统（distributed system）的某种定义是：一个各部分允许独立失败的系统。 反应式设计的本质是分布式的：你想对相互隔离的组件进行建模，并且只通过位置透明的消息传递进行交互，从而建立具有回弹性的监督层级结构。这意味着，最终产生的应用程序结构也将要面对分布式所带来的各种后果。在无状态系统中，这类后果主要与失败处理有关，恢复处理手段则如前一章所述。但是当系统需要维护状态时，就没有那么简单了。即使系统的每个部分都完美地工作，时间也是一个（可能导致失败的）因素。正如你在第 2 章中所学习到的，分布式会导致的其中一个后果就是无法保证强一致性（strong consistency）。在这一章中，你将学到有界一致性（delimited consistency），这是退而求其次的最优选。\n没有代码清单","title":"第8章——有界一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需使用非确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需使用非确定性","text":"这一章为全书最抽象的部分，对于初步理解后面章节来说，这一章的内容并非必需。你可以先直接跳到第10章看看，只要你保证之后还会回来。","title":"第9章——按需使用非确定性"},{"location":"/chapter-09/index.html#9-2-函数式反应式编程","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"9.2 函数式反应式编程"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"现在你已经建立了一套层级分明、封装明确的模块。这些模块可以呈现一个应用系统，你需要合理编排他们之间的互动以交付需求。前面章节贯穿而成的关键点是：模块之间只通过消息传递机制异步地进行通信。它们并不直接共享可变状态。一路上，你已经看到这种方式的诸多优点。它使得伸缩性和回弹性成为了可能，尤其是在与位置透明性相呼应的时候。而其对比方案，共享状态的并发，则比较难以正确地实现。\n没有代码清单","title":"第10章——消息流"},{"location":"/part3.html","text":"","title":"第三部分 设计模式 ·"},{"location":"/part3.html#第三部分-设计模式","text":"到目前为止，我们在讨论什么是反应式，以及为什么要应用反应式上已经花费了不少时间。现在是时候关注如何应用反应式了。 在第三部分中，我们将介绍一些可以帮助你实现反应式应用程序的设计模式。我们将首先讨论如何进行测试，以确保你的应用程序是反应式的，这样你就可以有信心接下来的的应用构建是都满足反应式契约的：无论从最小的功能组件，还是到整个跨数据中心部署结构。 然后，我们将深入探讨一些在反应式概念的各个维度上构建反应式系统的特定模式。\n在这一部分中，你将学习到以下内容：\n测试反应式系统，并特别强调异步测试 将内部和外部容错应用到你的应用程序中 管理反应式应用程序的资源 管理应用程序内部及应用程序之间的消息和数据流通 管理反应式系统的状态，以及持久化数据的过程\n对于每一个模式，我们将先以一个简短的段落介绍它的本质（以便回顾时作参考），接着介绍模式会出现在系统中的场景，并给出一个将模式应用到具体问题的详细示例。然后总结出每个模式所能解决的问题、典型特征和适用范围。\n第二部分讨论了搭建反应式系统的基础构建块，在你阅读后续章节时，值得经常回顾第二部分中的相关背景——以我们的经验，通常对一个主题进行二次攻关才会带来灵光乍现的瞬间","title":"第三部分 设计模式"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-11/index.html#11-3-异步测试","text":"代码清单 11-1 测试一个完全同步的翻译函数\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\ntranslate(input) should be(output)\nAsyncSpec.scala\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = translate(input)\n// what now?\nActorSpec.scala\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\n// when can we continue?\nAsyncSpecWithWhile.scala\nwhile (!future.isCompleted) Thread.sleep(50)\nAsyncSpecWithWhileLoopIterationsBounded.scala\nvar i = 20\nwhile (!future.isCompleted && i > 0) {\n  i -= 1\n  Thread.sleep(50)\n}\nif (i == 0) fail(\"translation was not received in time\")\n代码清单 11-2 等待结果的动作在翻译过程中同步阻塞\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval result = Await.result(translate(input), 1.second)\nresult should be(output)\n代码清单 11-3 使用 TestProbe 预期答复\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(1.second, output)\n代码清单 11-4 使用 TestProbe 接收调度程序的响应\nval probe = TestProbe()\n\nval start = Timestamp.now\nscheduler ! Schedule(probe.ref, \"tick\", 1.second)\nprobe.expectMsg(2.seconds, \"tick\")\n\nval stop = Timestamp.now\n\nval duration = stop - start\nassert(duration > 950.millis, \"tick came in early\")\nassert(duration < 1050.millis, \"tick came in late\")\n// when can we continue?\n代码清单 11-5 确定第 95 百分位的延迟\nval probe = TestProbe()\n\nval echo = echoService(\"keepSLA\")\nval N = 200\nval timings = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  echo ! Request(string, probe.ref)\n  probe.expectMsg(100.millis, s\"test run $i\", Response(string))\n  val stop = Timestamp.now\n  stop - start\n}\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 1.millisecond\nninetyfifthPercentile.toFiniteDuration should be <= SLA\n代码清单 11-6 用 Ask 模式并行地生成测试样本\nval echo = echoService(\"keepSLAWithFuture\")\n\nval N = 10000\nval timingFutures = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  (echo ? (Request(string, _))) collect {\n    case Response(`string`) ⇒ Timestamp.now - start\n  }\n}\n\nval futureOfTimings = Future.sequence(timingFutures)\nval timings = Await.result(futureOfTimings, 5.seconds)\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\n\nval SLA = if (Helpers.isCiTest) 500.milliseconds else 100.milliseconds\n\nninetyfifthPercentile.toFiniteDuration should be < SLA\n代码清单 11-7 使用自定义 Actor 来限制并行测试样本的数量\nval echo = echoService(\"keepSLAInParallel\")\nval probe = TestProbe()\n\nval N = 10000\nval maxParallelism = 500\nval controller = system.actorOf(\n  Props[ParallelSLATester],\n  \"keepSLAInParallelController\")\ncontroller ! TestSLA(echo, N, maxParallelism, probe.ref)\n\nval result = Try(probe.expectMsgType[SLAResponse]).recover {\n  case ae: AssertionError ⇒\n    controller ! AbortSLATest\n    val result = probe.expectMsgType[SLAResponse]\n    info(s\"controller timed out, state so far is $result\")\n    throw ae\n}.get\n\n// discard top 5%\nval sorted = result.timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 2.milliseconds\n\nninetyfifthPercentile should be < SLA\n代码清单 11-8 验证没有收到额外的消息\nimport scala.concurrent.duration._\nval scheduler = system.actorOf(Scheduler.props)\n\nval probe = TestProbe()\nscheduler ! ScheduleRepeatedly(probe.ref, 1.second, \"tick\")\nval token = probe.expectMsgType[SchedulerToken]\nprobe.expectMsg(1500.millis, \"tick\")\nscheduler ! CancelSchedule(token, probe.ref)\nprobe.expectMsg(100.millis, ScheduleCanceled)\nprobe.expectNoMessage(2.seconds)\n代码清单 11-9 对具有关联 ID 的请求匹配响应\nval ingestService = system.actorOf(DataIngester.props)\nval probe = TestProbe()\ningestService ! Retrieve(url, \"myID\", probe.ref)\nval replies = probe.receiveWhile(1.second) {\n  case r @ Record(\"myID\", _) ⇒ r\n}\nprobe.expectMsg(0.seconds, EOF)\n代码清单 11-10 强制同步执行：仅对非阻塞处理安全\nval tr = new TranslationService\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval ec = SynchronousEventLoop\nval future = tr.translate(input, ec)\nfuture.value.get should be(Success(output))\n代码清单 11-11 使用 CallingThreadDispatcher 来处理调用线程上的消息\nval translationService = system.actorOf(\n  TranslationService.props.withDispatcher(\"akka.test.calling-thread-dispatcher\"))\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(0.seconds, output)\n代码清单 11-12 将超时参数移到外部配置\nval tr = new TranslationService\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = tr.translate(input)\neventually {\n  future.value.get should be(Success(output))\n}\n代码清单 11-13 异步地处理响应，从而创建完全反应式的测试\nval echo = echoService()\nval N = 10000\nval maxParallelism = 500\nval controller = system.actorOf(\n  Props[ParallelSLATester],\n  \"keepSLAInParallelAndAsyncController\")\nval future = controller ? (TestSLA(echo, N, maxParallelism, _))\nfor (SLAResponse(timings, outstanding) ← future) yield {\n\n  val sorted = timings.sorted\n  val ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\n  info(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\n  val SLA = if (Helpers.isCiTest) 25.milliseconds else 2.milliseconds\n\n  ninetyfifthPercentile should be > SLA\n}\n代码清单 11-14 使用 async 和 await 提高异步测试的可读性\nasync {\n  val input = \"Hur mår du?\"\n  val output = \"How are you?\"\n  await(translate(input).withTimeout(5.seconds)) should be(output)\n}\n代码清单 11-15 在 JavaScript 中测试翻译服务\ndescribe('Translator', function () {\n    describe('#translate()', function () {\n        it('should yield the correct result', function () {\n            return tr.translate('Hur mår du?')\n                .should.eventually.equal('How are you?');\n        })\n    })\n});\n代码清单 11-16 使用请求-响应工厂来生成测试流量\nasync {\n  val echo = echoService(\"keepSLAwithSupport\")\n  val latencySupport = new LatencyTestSupport(system)\n  val latenciesFuture = latencySupport.measure(\n    count = 10000,\n    maxParallelism = 500) { i ⇒\n    val message = s\"test$i\"\n    SingleResult(echo ? (Request(message, _)), Response(message))\n  }\n  val latencies = await(akka.pattern.after(\n    20.seconds,\n    system.scheduler)(latenciesFuture))\n\n  info(s\"latency info: $latencies\")\n  latencies.failureCount should be(0)\n  val SLA = if (Helpers.isCiTest) 50.milliseconds else 10.milliseconds\n  latencies.quantile(0.99) should be < SLA\n}\n代码清单 11-17 简单的翻译 API\nfinal case class TranslateV1(query: String, replyTo: ActorRef)\n代码清单 11-18 将更严格的类型添加到翻译 API\nfinal case class TranslateV2(\n  phrase:         String,\n  inputLanguage:  String,\n  outputLanguage: String,\n  replyTo:        ActorRef)\n\nsealed trait TranslationResponseV2\n\nfinal case class TranslationV2(\n  inputPhrase:    String,\n  outputPhrase:   String,\n  inputLanguage:  String,\n  outputLanguage: String)\n\nfinal case class TranslationErrorV2(\n  inputPhrase:    String,\n  inputLanguage:  String,\n  outputLanguage: String,\n  errorMessage:   String)\n代码清单 11-19 测试翻译版本适配器\nval v1 = TestProbe()\nval v2 = system.actorOf(propsV2(v1.ref))\nval client = TestProbe()\n\n// initiate a request to the adapter\nv2 ! TranslateV2(\"Hur mår du?\", \"sv\", \"en\", client.ref)\n\n// verify that the adapter asks the V1 service back-end\nval req1 = v1.expectMsgType[TranslateV1]\nreq1.query should be(\"sv:en:Hur mår du?\")\n\n// initiate a reply\nreq1.replyTo ! \"How are you?\"\n\n// verify that the adapter transforms it correctly\nclient.expectMsg(TranslationV2(\"Hur mår du?\", \"How are you?\", \"sv\", \"en\"))\n\n// now verify translation errors\nv2 ! TranslateV2(\"Hur är läget?\", \"sv\", \"en\", client.ref)\nval req2 = v1.expectMsgType[TranslateV1]\n// this implicitly verifies that no other communication happened with V1\nreq2.query should be(\"sv:en:Hur är läget?\")\nreq2.replyTo ! \"error:cannot parse input 'sv:en:Hur är läget?'\"\nclient.expectMsg(TranslationErrorV2(\"Hur är läget?\", \"sv\", \"en\",\n  \"cannot parse input 'sv:en:Hur är läget?'\"))\n\nv1.expectNoMessage(3.second)\n代码清单 11-20 模拟错误过程\ncase object ExpectNominal\n\ncase object ExpectError\n\nfinal case class Unexpected(msg: Any)\n\nclass MockV1(reporter: ActorRef) extends Actor {\n  def receive: Receive = initial\n\n  override def unhandled(msg: Any): Unit = {\n    reporter ! Unexpected(msg)\n  }\n\n  private val initial: Receive = {\n    case ExpectNominal ⇒ context.become(expectingNominal)\n    case ExpectError   ⇒ context.become(expectingError)\n  }\n\n  def expectingNominal: Receive = {\n    case TranslateV1(\"sv:en:Hur mår du?\", replyTo) ⇒\n      replyTo ! \"How are you?\"\n      context.become(initial)\n  }\n\n  def expectingError: Receive = {\n    case TranslateV1(other, replyTo) ⇒\n      replyTo ! s\"error:cannot parse input '$other'\"\n      context.become(initial)\n  }\n}\n代码清单 11-21 测试正确的错误处理\nval asyncErrors = TestProbe()\nval v1 = system.actorOf(mockV1props(asyncErrors.ref))\nval v2 = system.actorOf(propsV2(v1))\nval client = TestProbe()\n\n// initiate a request to the adapter\nv1 ! ExpectNominal\nv2 ! TranslateV2(\"Hur mår du?\", \"sv\", \"en\", client.ref)\n\n// verify that the adapter transforms it correctly\nclient.expectMsg(TranslationV2(\"Hur mår du?\", \"How are you?\", \"sv\", \"en\"))\n\n// non-blocking check for async errors\nasyncErrors.expectNoMessage(0.seconds)\n\n// now verify translation errors\nv1 ! ExpectError\nv2 ! TranslateV2(\"Hur är läget?\", \"sv\", \"en\", client.ref)\nclient.expectMsg(TranslationErrorV2(\"Hur är läget?\", \"sv\", \"en\",\n  \"cannot parse input 'sv:en:Hur är läget?'\"))\n\n// final check for async errors\nasyncErrors.expectNoMessage(1.second)","title":"11.3 异步测试"},{"location":"/chapter-11/index.html#11-6-测试回弹性","text":"代码清单 11-22 要测试的基本 Actor\nclass MyActor extends Actor {\n  def receive: Receive = {\n    case _ ⇒ throw new NullPointerException\n  }\n}\n代码清单 11-23 为被测 Actor 提供测试上下文\nclass StepParent extends Actor {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case ex ⇒ Restart\n  }\n\n  def receive: Receive = {\n    case p: Props ⇒\n      sender ! context.actorOf(p, \"child\")\n  }\n}\n代码清单 11-24 在 StepParent 的上下文中测试 Actor\nclass StepParentSpec extends WordSpec with Matchers with BeforeAndAfterAll {\n  implicit val system: ActorSystem = ActorSystem()\n\n  \"An actor that throws an exception\" must {\n    \"Result in the supervisor returning a reference to that actor\" in {\n      val testProbe = TestProbe()\n      val parent = system.actorOf(Props[StepParent], \"stepParent\")\n      parent.tell(Props[MyActor], testProbe.ref)\n      val child = testProbe.expectMsgType[ActorRef]\n      // ...\n      // Test whatever we want in the actor\n    }\n  }\n\n  override def afterAll(): Unit = {\n    val terminated = system.terminate()\n    Await.ready(terminated, Duration.Inf)\n  }\n}\n代码清单 11-25 将失败报告给指定的 Actor\nclass FailureParent(failures: ActorRef) extends Actor {\n  private val props: Props = Props[MyFailureParentActor]\n  private val child: ActorRef = context.actorOf(props, \"child\")\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case f ⇒ failures ! f; Stop\n  }\n\n  def receive: Receive = {\n    case msg ⇒ child forward msg\n  }\n}\n代码清单 11-26 在测试中移除监督\ncase object TestFailureParentMessage\n\nclass FailureParentSpec extends WordSpec\n  with Matchers with BeforeAndAfterAll {\n  implicit val system: ActorSystem = ActorSystem()\n\n  \"Using a FailureParent\" must {\n    \"Result in failures being collected and returned\" in {\n      val failures = TestProbe()\n      val failureParent = system.actorOf(Props(new FailureParent(failures.ref)))\n      failureParent ! TestFailureParentMessage\n      failures.expectMsgType[NullPointerException]\n    }\n  }\n\n  override def afterAll(): Unit = {\n    val terminated = system.terminate()\n    Await.ready(terminated, Duration.Inf)\n  }\n}","title":"11.6 测试回弹性"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"在这一章中，你将学习到在设计应用程序时如何应对失败出现的可能性。我们将通过具体地构建一个具有回弹性的计算引擎来演示几个相应的模式，这个系统允许提交批处理作业，并在有着弹性调度的硬件资源上执行。我们将基于你在第6章和第7章所学习到的知识进行展开，因此，你可能想要回顾一下之前的内容。","title":"第12章——容错及恢复模式"},{"location":"/chapter-12/index.html#12-4-断路器模式","text":"代码清单 12-1 利用断路器使得失败组件有时间恢复\nprivate object StorageFailed extends RuntimeException\n\nimport akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n\nprivate def sendToStorage(job: Job): Future[StorageStatus] = {\n  val f: Future[StorageStatus] = ??? //...\n  f.map {\n    case StorageStatus.Failed => throw StorageFailed\n    case other => other\n  }\n}\n\nimport scala.concurrent.duration._\n\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  5,\n  300.millis,\n  30.seconds,\n)\n\ndef persist(job: Job): Future[StorageStatus] = {\n  breaker\n    .withCircuitBreaker(sendToStorage(job))\n    .recover {\n      case StorageFailed => StorageStatus.Failed\n      case _: TimeoutException => StorageStatus.Unknown\n      case _: CircuitBreakerOpenException => StorageStatus.Failed\n    }\n}\n代码清单12-2 使用速率限制器保护组件\nimport scala.concurrent.Future\nimport scala.concurrent.duration.{ Deadline, FiniteDuration }\n\ncase object RateLimitExceeded extends RuntimeException\n\nclass RateLimiter(requests: Int, period: FiniteDuration) {\n  private val startTimes = {\n    val onePeriodAgo = Deadline.now - period\n    Array.fill(requests)(onePeriodAgo)\n  }\n  private var position = 0\n\n  private def lastTime = startTimes(position)\n\n  private def enqueue(time: Deadline): Unit = {\n    startTimes(position) = time\n    position += 1\n    if (position == requests) position = 0\n  }\n\n  def call[T](block: ⇒ Future[T]): Future[T] = {\n    val now = Deadline.now\n    if ((now - lastTime) < period) {\n      Future.failed(RateLimitExceeded)\n    } else {\n      enqueue(now)\n      block\n    }\n  }\n}\n代码清单12-3 断路器：限制来自同一个客户端的请求\nprivate val limiter = new RateLimiter(100, 2.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  limiter\n    .call(persist(job))\n    .recover {\n      case RateLimitExceeded ⇒ StorageStatus.Failed\n    }\n}\n代码清单12-4 门控一个客户端\nprivate val limiter = new RateLimiter(100, 2.seconds)\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  10, Duration.Zero, 10.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(limiter.call(persist(job)))\n    .recover {\n      case RateLimitExceeded              ⇒ StorageStatus.Failed\n      case _: CircuitBreakerOpenException ⇒ StorageStatus.Gated\n    }\n}","title":"12.4. 断路器模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-13/index.html#13-1-主动-被动复制模式","text":"Protocol\nsealed trait Command\n\nsealed trait Result\n\nfinal case class Put(key: String, value: JsValue, replyTo: ActorRef) extends Command\n\nfinal case class PutConfirmed(key: String, value: JsValue) extends Result\n\nfinal case class PutRejected(key: String, value: JsValue) extends Result\n\nfinal case class Get(key: String, replyTo: ActorRef) extends Command\n\nfinal case class GetResult(key: String, value: Option[JsValue]) extends Result\n代码清单 13-1 单例作为主动副本来接管\nclass Active(\n  localReplica:      ActorRef,\n  replicationFactor: Int,\n  maxQueueSize:      Int) extends Actor with Stash with ActorLogging {\n\n  private var theStore: Map[String, JsValue] = _\n  private var seqNr: Iterator[Int] = _\n\n  log.info(\"taking over from local replica\")\n  localReplica ! TakeOver(self)\n\n  def receive: Receive = {\n    case InitialState(m, s) ⇒\n      log.info(\"took over at sequence {}\", s)\n      theStore = m\n      seqNr = Iterator from s\n      context.become(running)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  val running: Receive = ??? //...\n}\n代码清单 13-2 主动副本传播复制请求\nclass Active(\n  localReplica:      ActorRef,\n  replicationFactor: Int,\n  maxQueueSize:      Int) extends Actor with Stash with ActorLogging {\n  // ...\n  private val MaxOutstanding = maxQueueSize / 2\n\n  private var theStore: Map[String, JsValue] = _\n  private var seqNr: Iterator[Int] = _\n  private val toReplicate = mutable.Queue.empty[Replicate]\n  private var replicating = TreeMap.empty[Int, (Replicate, Int)]\n\n  private var rejected = 0\n\n  val timer: Cancellable =\n    context.system.scheduler.schedule(\n      1.second, 1.second, self, Tick)(context.dispatcher)\n\n  override def postStop(): Unit = timer.cancel()\n\n  log.info(\"taking over from local replica\")\n  localReplica ! TakeOver(self)\n\n  def receive: Receive = {\n    case InitialState(m, s) ⇒\n      log.info(\"took over at sequence {}\", s)\n      theStore = m\n      seqNr = Iterator from s\n      context.become(running)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  val running: Receive = {\n    case p @ Put(key, value, replyTo) ⇒\n      if (toReplicate.size < MaxOutstanding) {\n        toReplicate.enqueue(Replicate(seqNr.next, key, value, replyTo))\n        replicate()\n      } else {\n        rejected += 1\n        replyTo ! PutRejected(key, value)\n      }\n    case Get(key, replyTo) ⇒\n      replyTo ! GetResult(key, theStore get key)\n    case Tick ⇒\n      replicating.valuesIterator foreach {\n        case (replicate, _) ⇒ disseminate(replicate)\n      }\n      if (rejected > 0) {\n        log.info(\"rejected {} PUT requests\", rejected)\n        rejected = 0\n      }\n    case Replicated(confirm) ⇒\n      replicating.get(confirm) match {\n        case None ⇒ // already removed\n        case Some((rep, 1)) ⇒\n          replicating -= confirm\n          theStore += rep.key -> rep.value\n          rep.replyTo ! PutConfirmed(rep.key, rep.value)\n        case Some((rep, n)) ⇒\n          replicating += confirm -> (rep, n - 1)\n      }\n      replicate()\n  }\n\n  private def replicate(): Unit =\n    if (replicating.size < MaxOutstanding && toReplicate.nonEmpty) {\n      val r = toReplicate.dequeue()\n      replicating += r.seq -> (r, replicationFactor)\n      disseminate(r)\n    }\n\n  private def disseminate(r: Replicate): Unit = {\n    val req = r.copy(replyTo = self)\n    val members = Cluster(context.system).state.members\n    members.foreach(m ⇒ replicaOn(m.address) ! req)\n  }\n\n  private def replicaOn(addr: Address): ActorSelection =\n    context.actorSelection(\n      localReplica.path.toStringWithAddress(addr))\n}\n代码清单 13-3 通过将JSON文件写入到本地磁盘来实现持久化\nimport java.io.File\n\nimport akka.actor.ActorRef\nimport play.api.libs.json.{ JsValue, Json, OFormat }\nimport sbt.io.IO\n\nobject Persistence {\n\n  final case class Database(seq: Int, kv: Map[String, JsValue])\n\n  object Database {\n    implicit val format: OFormat[Database] = Json.format[Database]\n  }\n\n  def persist(name: String, seq: Int, kv: Map[String, JsValue]): Unit = {\n    val bytes = Json.stringify(Json.toJson(Database(seq, kv)))\n    val current = new File(s\"./theDataBase-$name.json\")\n    val next = new File(s\"./theDataBase-$name.json.new\")\n    IO.write(next, bytes)\n    IO.move(next, current) // atomically update the database\n  }\n\n  def readPersisted(name: String): Database = {\n    val file = new File(s\"theDataBase-$name.json\")\n    if (file.exists()) Json.parse(IO.read(file)).as[Database]\n    else Database(0, Map.empty)\n  }\n}\n代码清单 13-4 被动副本追踪它们是否是最新的版本\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = mutable.Queue.empty[Replicate]\n\n  private val name: String =\n    Cluster(context.system).selfAddress.toString.replaceAll(\"[:/]\", \"_\")\n\n  def receive: Receive = readPersisted(name) match {\n    case Database(s, kv) ⇒\n      log.info(\"started at sequence {}\", s)\n      upToDate(kv, s + 1)\n  }\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    case TakeOver(active) ⇒\n      log.info(\"active replica starting at sequence {}\", expectedSeq)\n      active ! InitialState(theStore, expectedSeq)\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒\n      replyTo ! Replicated(s)\n    case r: Replicate if r.seq == expectedSeq ⇒\n      val nextStore = theStore + (r.key -> r.value)\n      persist(name, expectedSeq, nextStore)\n      r.replyTo ! Replicated(r.seq)\n      applied.enqueue(r)\n      context.become(upToDate(nextStore, expectedSeq + 1))\n    case r: Replicate ⇒\n      if (r.seq - expectedSeq > maxLag)\n        fallBehind(expectedSeq, TreeMap(r.seq -> r))\n      else\n        missingSomeUpdates(theStore, expectedSeq, Set.empty, TreeMap(r.seq -> r))\n    case GetSingle(s, replyTo) ⇒\n      log.info(\"GetSingle from {}\", replyTo)\n      if (applied.nonEmpty && applied.head.seq <= s && applied.last.seq >= s)\n        replyTo ! applied.find(_.seq == s).get\n      else if (s < expectedSeq) replyTo ! InitialState(theStore, expectedSeq)\n    case GetFull(replyTo) ⇒\n      log.info(\"sending full info to {}\", replyTo)\n      replyTo ! InitialState(theStore, expectedSeq)\n  }\n\n  def fallBehind(\n    expectedSeq: Int,\n    _waiting:    TreeMap[Int, Replicate]): Unit = ???\n\n  def missingSomeUpdates(\n    theStore:        Map[String, JsValue],\n    expectedSeq:     Int,\n    prevOutstanding: Set[Int],\n    waiting:         TreeMap[Int, Replicate]): Unit = ???\n}\n代码清单 13-5 被动副本在滞后过多时请求一份全量更新\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = mutable.Queue.empty[Replicate]\n  private var awaitingInitialState = Option.empty[ActorRef]\n\n  private val name: String =\n    Cluster(context.system).selfAddress.toString.replaceAll(\"[:/]\", \"_\")\n  private val cluster = Cluster(context.system)\n  private val random = new Random\n\n  private var tickTask = Option.empty[Cancellable]\n\n  def scheduleTick(): Unit = {\n    tickTask foreach (_.cancel())\n    tickTask = Some(context.system.scheduler.scheduleOnce(\n      askAroundInterval, self, DoConsolidate)(context.dispatcher))\n  }\n\n  def receive: Receive = readPersisted(name) match {\n    case Database(s, kv) ⇒\n      log.info(\"started at sequence {}\", s)\n      upToDate(kv, s + 1)\n  }\n\n  def caughtUp(theStore: Map[String, JsValue], expectedSeq: Int): Unit = {\n    awaitingInitialState foreach (_ ! InitialState(theStore, expectedSeq))\n    awaitingInitialState = None\n    context.become(upToDate(theStore, expectedSeq))\n  }\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    // Cases shown previously elided\n    case TakeOver(active)                                   ⇒ ??? //...\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒ ??? //...\n    case r: Replicate if r.seq == expectedSeq               ⇒ ??? //...\n    case r: Replicate                                       ⇒ ??? //...\n    case GetSingle(s, replyTo)                              ⇒ ??? //...\n    case GetFull(replyTo) ⇒\n      log.info(\"sending full info to {}\", replyTo)\n      replyTo ! InitialState(theStore, expectedSeq)\n  }\n\n  def fallBehind(expectedSeq: Int, _waiting: TreeMap[Int, Replicate]): Unit = {\n    askAroundFullState()\n    scheduleTick()\n    var waiting = _waiting\n    context.become {\n      case Replicate(s, _, _, replyTo) if s < expectedSeq ⇒\n        replyTo ! Replicated(s)\n      case r: Replicate ⇒\n        waiting += (r.seq -> r)\n      case TakeOver(active) ⇒\n        log.info(\n          \"delaying active replica takeOver, at seq {} while highest is {}\",\n          expectedSeq, waiting.lastKey)\n        awaitingInitialState = Some(active)\n      case InitialState(m, s) if s > expectedSeq ⇒\n        log.info(\n          \"received newer state at sequence {} (was at {})\", s, expectedSeq)\n        persist(name, s, m)\n        waiting.to(s).valuesIterator foreach (r ⇒ r.replyTo ! Replicated(r.seq))\n        val nextWaiting = waiting.from(expectedSeq)\n        consolidate(m, s + 1, Set.empty, nextWaiting)\n      case DoConsolidate ⇒\n        askAroundFullState()\n        scheduleTick()\n    }\n  }\n\n  private def consolidate(\n    theStore:    Map[String, JsValue],\n    expectedSeq: Int,\n    askedFor:    Set[Int],\n    waiting:     TreeMap[Int, Replicate]): Unit = ??? //...\n\n  private def getMembers(n: Int): Seq[Address] = {\n    // using .iterator to avoid one intermediate collection to be created\n    random.shuffle(cluster.state.members.iterator.map(_.address).toSeq).take(n)\n  }\n\n  private def askAroundFullState(): Unit = {\n    log.info(\"asking for full data\")\n    getMembers(1).foreach(addr ⇒ replicaOn(addr) ! GetFull(self))\n  }\n\n  private def replicaOn(addr: Address): ActorSelection =\n    context.actorSelection(self.path.toStringWithAddress(addr))\n}\n代码清单 13-6 计算直接可应用的队列前段的长度\nprivate val matches = (p: (Int, Int)) ⇒ p._1 == p._2\n\nprivate def consolidate(\n  theStore:    Map[String, JsValue],\n  expectedSeq: Int,\n  askedFor:    Set[Int],\n  waiting:     TreeMap[Int, Replicate]): Unit = {\n\n  // calculate applicable prefix length\n  val prefix = waiting.keysIterator\n    .zip(Iterator from expectedSeq)\n    .takeWhile(matches)\n    .size\n\n  val nextStore = waiting.valuesIterator\n    .take(prefix)\n    .foldLeft(theStore) { (store, replicate) ⇒\n      persist(name, replicate.seq, theStore)\n      replicate.replyTo ! Replicated(replicate.seq)\n      applied.enqueue(replicate)\n      store + (replicate.key -> replicate.value)\n    }\n  val nextWaiting = waiting.drop(prefix)\n  val nextExpectedSeq = expectedSeq + prefix\n\n  // cap the size of the applied buffer\n  applied.drop(Math.max(0, applied.size - maxLag))\n\n  if (nextWaiting.nonEmpty) {\n    // check if we fell behind by too much\n    if (nextWaiting.lastKey - nextExpectedSeq > maxLag)\n      fallBehind(nextExpectedSeq, nextWaiting)\n    else missingSomeUpdates(nextStore, nextExpectedSeq,\n      askedFor, nextWaiting)\n  } else caughtUp(nextStore, nextExpectedSeq)\n}\n代码清单 13-7 确定更新队列里的数据缺口是否可以被一一填补\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = mutable.Queue.empty[Replicate]\n  private var awaitingInitialState = Option.empty[ActorRef]\n\n  // ... Initialization elided\n  def receive: Receive = ??? //...\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    case TakeOver(active)                                   ⇒ ??? //...\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒ ??? //...\n    case r: Replicate if r.seq == expectedSeq               ⇒ ??? //...\n    case r: Replicate                                       ⇒ ??? //...\n    case GetFull(replyTo)                                   ⇒ ??? //...\n    case GetSingle(s, replyTo) ⇒\n      log.info(\"GetSingle from {}\", replyTo)\n      if (applied.nonEmpty &&\n        applied.head.seq <= s && applied.last.seq >= s) {\n        replyTo ! applied.find(_.seq == s).get\n      } else if (s < expectedSeq) {\n        replyTo ! InitialState(theStore, expectedSeq)\n      }\n  }\n\n  def missingSomeUpdates(\n    theStore:        Map[String, JsValue],\n    expectedSeq:     Int,\n    prevOutstanding: Set[Int],\n    waiting:         TreeMap[Int, Replicate]): Unit = {\n\n    val askFor = (expectedSeq to waiting.lastKey).iterator\n      .filterNot(seq ⇒\n        waiting.contains(seq) ||\n          prevOutstanding.contains(seq)).toList\n\n    askFor foreach askAround\n\n    if (prevOutstanding.isEmpty) {\n      scheduleTick()\n    }\n    val outstanding = prevOutstanding ++ askFor\n\n    context.become {\n      case Replicate(s, _, _, replyTo) if s < expectedSeq ⇒\n        replyTo ! Replicated(s)\n      case r: Replicate ⇒\n        consolidate(theStore, expectedSeq,\n          outstanding - r.seq,\n          waiting + (r.seq -> r))\n      case TakeOver(active) ⇒\n        log.info(\n          \"delaying active replica takeOver, at seq {} while highest is {}\",\n          expectedSeq, waiting.lastKey)\n        awaitingInitialState = Some(active)\n      case GetSingle(s, replyTo) ⇒\n        log.info(\"GetSingle from {}\", replyTo)\n        if (applied.nonEmpty &&\n          applied.head.seq <= s &&\n          applied.last.seq >= s) {\n          replyTo ! applied.find(_.seq == s).get\n        } else if (s < expectedSeq) {\n          replyTo ! InitialState(theStore, expectedSeq)\n        }\n      case GetFull(replyTo) ⇒\n        log.info(\"sending full info to {}\", replyTo)\n        replyTo ! InitialState(theStore, expectedSeq)\n      case DoConsolidate ⇒\n        outstanding foreach askAround\n        scheduleTick()\n    }\n  }\n\n  private def askAround(seq: Int): Unit = {\n    log.info(\"asking around for sequence number {}\", seq)\n    getMembers(askAroundCount)\n      .foreach(addr ⇒ replicaOn(addr) ! GetSingle(seq, self))\n  }\n\n  // ... Other helpers elided\n  private def consolidate(\n    theStore:    Map[String, JsValue],\n    expectedSeq: Int,\n    askedFor:    Set[Int],\n    waiting:     TreeMap[Int, Replicate]): Unit = ???\n\n  private def getMembers(n: Int): Seq[Address] = ???\n\n  private def replicaOn(addr: Address): ActorSelection = ???\n\n  def scheduleTick(): Unit = ???\n\n}","title":"13.1 主动-被动复制模式"},{"location":"/chapter-13/index.html#13-2-多主复制模式","text":"代码清单 13-8 使用 CKite 来实现键值存储\nclass KVStore extends StateMachine {\n  private var map = mutable.Map[String, String]()\n  private var lastIndex: Long = 0\n\n  def applyWrite: PartialFunction[(Long, WriteCommand[_]), String] = {\n    case (index, Put(key: String, value: String)) ⇒\n      map.put(key, value)\n      lastIndex = index\n      value\n  }\n\n  def applyRead: PartialFunction[ReadCommand[_], Option[String]] = {\n    case Get(key) ⇒ map.get(key)\n  }\n\n  def getLastAppliedIndex: Long = lastIndex\n\n  def restoreSnapshot(byteBuffer: ByteBuffer): Unit = {\n    map = Serializer.deserialize[mutable.Map[String, String]](byteBuffer.array())\n  }\n\n  def takeSnapshot(): ByteBuffer =\n    ByteBuffer.wrap(Serializer.serialize(map))\n\n}\n代码清单 13-9 按照复制状态机来实例化KVStore\nobject KVStoreBootstrap extends App {\n  val ckite =\n    CKiteBuilder()\n      .stateMachine(new KVStore())\n      .rpc(FinagleThriftRpc)\n      .storage(MapDBStorage())\n      .build\n  ckite.start()\n\n  HttpServer(ckite).start()\n}\nckite api\nval consistentRead: Future[Option[String]] = ckite.read(Get(key))\nval possibleStaleRead: Future[Option[String]] = ckite.readLocal(Get(key))\nval write: Future[String] = ckite.write(Put(key, value))\n代码清单 13-10 图13-1中图形的代码表示\nfinal case class Status(name: String)(\n  _predecessor: ⇒ Set[Status], _successor: ⇒ Set[Status]) extends ReplicatedData {\n\n  type T = Status\n\n  def merge(that: Status): Status = mergeStatus(this, that)\n\n  @volatile lazy val predecessors: Set[Status] = _predecessor\n  @volatile lazy val successors: Set[Status] = _successor\n\n}\n\nval New: Status =\n  Status(\"new\")(Set.empty, Set(Scheduled, Cancelled))\nval Scheduled: Status =\n  Status(\"scheduled\")(Set(New), Set(Executing, Cancelled))\nval Executing: Status =\n  Status(\"executing\")(Set(Scheduled), Set(Aborted, Finished))\nval Finished: Status =\n  Status(\"finished\")(Set(Executing, Aborted), Set.empty)\nval Cancelled: Status =\n  Status(\"cancelled\")(Set(New, Scheduled), Set(Aborted))\nval Aborted: Status =\n  Status(\"aborted\")(Set(Cancelled, Executing), Set(Finished))\n代码清单 13-11 合并两个状态来产生第三个合并后的状态\ndef mergeStatus(left: Status, right: Status): Status = {\n  /*\n   * Keep the left Status in hand and determine whether it is a predecessor of\n   * the candidate, moving on to the candidate’s successor if not successful.\n   * The list of exclusions is used to avoid performing already determined\n   * unsuccessful comparisons again.\n   */\n  def innerLoop(candidate: Status, exclude: Set[Status]): Status =\n    if (isSuccessor(candidate, left, exclude)) {\n      candidate\n    } else {\n      val nextExclude = exclude + candidate\n      val branches =\n        candidate.successors.map(successor ⇒ innerLoop(successor, nextExclude))\n      branches.reduce((l, r) ⇒\n        if (isSuccessor(l, r, nextExclude)) r else l)\n    }\n\n  def isSuccessor(\n    candidate: Status,\n    fixed:     Status, exclude: Set[Status]): Boolean =\n    if (candidate == fixed) true\n    else {\n      val toSearch = candidate.predecessors -- exclude\n      toSearch.exists(pred ⇒ isSuccessor(pred, fixed, exclude))\n    }\n\n  innerLoop(right, Set.empty)\n}\n代码清单 13-12 使用 Akka Distributed Data 来传播状态变更\nclass ClientInterface extends Actor with ActorLogging {\n  private val replicator: ActorRef = DistributedData(context.system).replicator\n  private implicit val cluster: Cluster = Cluster(context.system)\n\n  def receive: Receive = {\n    case Submit(job) ⇒\n      log.info(\"submitting job {}\", job)\n      replicator ! Replicator.Update(\n        StorageComponent,\n        ORMap.empty[String, Status],\n        Replicator.WriteMajority(5.seconds),\n        Some(s\"submit $job\"))(_ + (job -> New))\n    case Cancel(job) ⇒\n      log.info(\"cancelling job {}\", job)\n      replicator ! Replicator.Update(\n        StorageComponent,\n        ORMap.empty[String, Status],\n        Replicator.WriteMajority(5.seconds),\n        Some(s\"cancel $job\"))(_ + (job -> Cancelled))\n    case r: Replicator.UpdateResponse[_] ⇒\n      log.info(\"received update result: {}\", r)\n    case PrintStatus ⇒\n      replicator ! Replicator.Get(\n        StorageComponent,\n        Replicator.ReadMajority(5.seconds))\n    case g: Replicator.GetSuccess[_] ⇒\n      log.info(\"overall status: {}\", g.get(StorageComponent))\n  }\n}\n代码清单 13-13 引入对于任务的请求标志\nclass Executor extends Actor with ActorLogging {\n  private val replicator: ActorRef = DistributedData(context.system).replicator\n  private implicit val cluster: Cluster = Cluster(context.system)\n\n  private var lastState = Map.empty[String, Status]\n\n  replicator ! Replicator.Subscribe(StorageComponent, self)\n\n  def receive: Receive = {\n    case Execute(job) ⇒\n      log.info(\"executing job {}\", job)\n      replicator ! Replicator.Update(\n        StorageComponent,\n        ORMap.empty[String, Status],\n        Replicator.WriteMajority(5.seconds), Some(job)) { map ⇒\n          require(map.get(job).contains(New))\n          map + (job -> Executing)\n        }\n    case Finish(job) ⇒\n      log.info(\"job {} finished\", job)\n      replicator ! Replicator.Update(\n        StorageComponent,\n        ORMap.empty[String, Status],\n        Replicator.WriteMajority(5.seconds))(_ + (job -> Finished))\n    case Replicator.UpdateSuccess(StorageComponent, Some(job)) ⇒\n      log.info(\"starting job {}\", job)\n    case r: Replicator.UpdateResponse[_] ⇒\n      log.info(\"received update result: {}\", r)\n    case ch: Replicator.Changed[_] ⇒\n      val current = ch.get(StorageComponent).entries\n      for {\n        (job, status) ← current.iterator\n        if status == Aborted\n        if !lastState.get(job).contains(Aborted)\n      } {\n        log.info(\"aborting job {}\", job)\n        lastState = current\n      }\n  }\n}","title":"13.2 多主复制模式"},{"location":"/chapter-13/index.html#13-3-主动-主动复制模式","text":"代码清单 13-14 用无协调工作的实现来开始主动-主动复制模式\nprivate final case class SeqCommand(seq: Int, cmd: Command, replyTo: ActorRef)\n\nprivate final case class SeqResult(\n  seq:     Int,\n  res:     Result,\n  replica: ActorRef,\n  replyTo: ActorRef)\n\nprivate final case class SendInitialData(toReplica: ActorRef)\n\nprivate final case class InitialData(map: Map[String, JsValue])\n\nclass Replica extends Actor with Stash {\n  private var map = Map.empty[String, JsValue]\n\n  def receive: Receive = {\n    case InitialData(m) ⇒\n      map = m\n      context.become(initialized)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  def initialized: Receive = {\n    case SeqCommand(seq, cmd, replyTo) ⇒\n      // tracking of sequence numbers and resents is elided here\n      cmd match {\n        case Put(key, value, r) ⇒\n          map += key -> value\n          replyTo ! SeqResult(seq, PutConfirmed(key, value), self, r)\n        case Get(key, r) ⇒\n          replyTo ! SeqResult(seq, GetResult(key, map get key), self, r)\n      }\n    case SendInitialData(toReplica) ⇒ toReplica ! InitialData(map)\n  }\n}\n代码清单 13-15 封装对于单个客户端请求的知悉情况\nprivate sealed trait ReplyState {\n  def deadline: Deadline\n\n  def missing: Set[ActorRef]\n\n  def add(res: SeqResult): ReplyState\n\n  def isFinished: Boolean = missing.isEmpty\n}\n\nprivate final case class Unknown(\n  deadline: Deadline,\n  replies:  Set[SeqResult],\n  missing:  Set[ActorRef],\n  quorum:   Int) extends ReplyState {\n\n  override def add(res: SeqResult): ReplyState = {\n    val nextReplies = replies + res\n    val nextMissing = missing - res.replica\n    if (nextReplies.size >= quorum) {\n      val answer =\n        replies.toSeq.groupBy(_.res)\n          .collectFirst {\n            case (k, s) if s.size >= quorum ⇒ s.head\n          }\n\n      if (answer.isDefined) {\n        val right = answer.get\n        val wrong = replies.collect {\n          case SeqResult(_, result, replica, _) if res != right ⇒ replica\n        }\n        Known(deadline, right, wrong, nextMissing)\n      } else if (nextMissing.isEmpty) {\n        Known.fromUnknown(deadline, nextReplies)\n      } else Unknown(deadline, nextReplies, nextMissing, quorum)\n    } else Unknown(deadline, nextReplies, nextMissing, quorum)\n  }\n}\n\nprivate final case class Known(\n  deadline: Deadline, reply: SeqResult,\n  wrong: Set[ActorRef], missing: Set[ActorRef]) extends ReplyState {\n\n  override def add(res: SeqResult): ReplyState = {\n    val nextWrong = if (res.res == reply.res)\n      wrong\n    else\n      wrong + res.replica\n    Known(deadline, reply, nextWrong, missing - res.replica)\n  }\n}\n\nprivate object Known {\n  def fromUnknown(deadline: Deadline, replies: Set[SeqResult]): Known = {\n    // did not reach consensus on this one, pick simple majority\n    val counts = replies.groupBy(_.res)\n    val biggest = counts.iterator.map(_._2.size).max\n    val winners = counts.collectFirst {\n      case (res, win) if win.size == biggest ⇒ win\n    }.get\n    val losers = (replies -- winners).map(_.replica)\n    Known(deadline, winners.head, losers, Set.empty)\n  }\n}\n代码清单 13-16 将副本当作子Actor管理\nclass Coordinator(N: Int) extends Actor {\n  private var replicas = (1 to N).map(_ ⇒ newReplica()).toSet\n  private val seqNr = Iterator from 0\n  private var replies = TreeMap.empty[Int, ReplyState]\n  private var nextReply = 0\n\n  override def supervisorStrategy: SupervisorStrategy =\n    SupervisorStrategy.stoppingStrategy\n\n  private def newReplica(): ActorRef =\n    context.watch(context.actorOf(Replica.props))\n\n  // schedule timeout messages for quiescent periods\n  context.setReceiveTimeout(1.second)\n\n  def receive: Receive = ({\n    case cmd: Command ⇒\n      val c = SeqCommand(seqNr.next, cmd, self)\n      replicas foreach (_ ! c)\n      replies += c.seq -> Unknown(5 seconds fromNow, Set.empty,\n        replicas, (replicas.size + 1) / 2)\n    case res: SeqResult if replies.contains(res.seq) &&\n      replicas.contains(res.replica) ⇒\n      val prevState = replies(res.seq)\n      val nextState = prevState.add(res)\n      replies += res.seq -> nextState\n    case Terminated(ref) ⇒\n      replaceReplica(ref, terminate = false)\n    case ReceiveTimeout ⇒\n  }: Receive) andThen { _ ⇒\n    doTimeouts()\n    sendReplies()\n    evictFinished()\n  }\n\n  //...\n  private def doTimeouts(): Unit = {\n    val now = Deadline.now\n    val expired = replies.iterator.takeWhile(_._2.deadline <= now)\n    for ((seq, state) ← expired) {\n      state match {\n        case Unknown(deadline, received, _, _) ⇒\n          val forced = Known.fromUnknown(deadline, received)\n          replies += seq -> forced\n        case Known(deadline, reply, wrong, missing) ⇒\n          replies += seq -> Known(deadline, reply, wrong, Set.empty)\n      }\n    }\n  }\n\n\n  @tailrec private def sendReplies(): Unit =\n    replies.get(nextReply) match {\n      case Some(k @ Known(_, reply, _, _)) ⇒\n        reply.replyTo ! reply.res\n        nextReply += 1\n        sendReplies()\n      case _ ⇒\n    }\n\n\n  @tailrec private def evictFinished(): Unit =\n    replies.headOption match {\n      case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished ⇒\n        wrong foreach (replaceReplica(_, terminate = true))\n        replies -= seq\n        evictFinished()\n      case _ ⇒\n    }\n\n  private def replaceReplica(r: ActorRef, terminate: Boolean): Unit =\n    if (replicas contains r) {\n      replicas -= r\n      if (terminate) r ! PoisonPill\n      val replica = newReplica()\n      replicas.head ! SendInitialData(replica)\n      replicas += replica\n    }\n\n}\n代码清单 13-17 按序发送回复\n@tailrec private def sendReplies(): Unit =\n  replies.get(nextReply) match {\n    case Some(k @ Known(_, reply, _, _)) ⇒\n      reply.replyTo ! reply.res\n      nextReply += 1\n      sendReplies()\n    case _ ⇒\n  }\n代码清单 13-18 一旦timeout，就强迫将“missing”回复转为“known”回复\nprivate def doTimeouts(): Unit = {\n  val now = Deadline.now\n  val expired = replies.iterator.takeWhile(_._2.deadline <= now)\n  for ((seq, state) ← expired) {\n    state match {\n      case Unknown(deadline, received, _, _) ⇒\n        val forced = Known.fromUnknown(deadline, received)\n        replies += seq -> forced\n      case Known(deadline, reply, wrong, missing) ⇒\n        replies += seq -> Known(deadline, reply, wrong, Set.empty)\n    }\n  }\n}\n代码清单 13-19 终止并替换未完成的副本\n@tailrec private def evictFinished(): Unit =\n  replies.headOption match {\n    case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished ⇒\n      wrong foreach (replaceReplica(_, terminate = true))\n      replies -= seq\n      evictFinished()\n    case _ ⇒\n  }\n\nprivate def replaceReplica(r: ActorRef, terminate: Boolean): Unit =\n  if (replicas contains r) {\n    replicas -= r\n    if (terminate) r ! PoisonPill\n    val replica = newReplica()\n    replicas.head ! SendInitialData(replica)\n    replicas += replica\n  }","title":"13.3 主动-主动复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"大多数系统都面临着一个共同的问题，那就是你需要管理或展现资源：文件存储空间、计算能力、对数据库或 Web API 的访问、如打印机和读卡器等物理设备，诸如此类。你所创建的某个组件，可能会独自为系统的其余部分提供某种资源，又或者你可能需要将其与外部资源整合。在这一章中，我们将讨论处理反应式应用程序中资源的模式。我们将着重讨论以下几种模式：","title":"第14章——资源管理模式"},{"location":"/chapter-14/index.html#14-1-资源封装模式","text":"代码清单 14-1 亚马逊EC2实例作为工作者节点\npublic Instance startInstance(final AWSCredentials credentials) {\n  final AmazonEC2 amazonEC2Client =\n      AmazonEC2ClientBuilder.standard()\n          .withCredentials(new AWSStaticCredentialsProvider(credentials))\n          .build();\n\n  final RunInstancesRequest runInstancesRequest =\n      new RunInstancesRequest()\n          .withImageId(\"\")\n          .withInstanceType(\"m1.small\")\n          .withMinCount(1)\n          .withMaxCount(1);\n\n  final RunInstancesResult runInstancesResult = amazonEC2Client.runInstances(runInstancesRequest);\n\n  final Reservation reservation = runInstancesResult.getReservation();\n  final List<Instance> instances = reservation.getInstances();\n\n  // there will be exactly one INSTANCE in this list, otherwise\n  // runInstances() would have thrown an exception\n  return instances.get(0);\n}\n代码清单 14-2 将EC2节点提升到一个Future中，从而简化失败处理过程\nprivate ExecutionContext executionContext; // value from somewhere\nprivate CircuitBreaker circuitBreaker; // value from somewhere\n\npublic Future<Instance> startInstanceAsync(AWSCredentials credentials) {\n  final Future<Instance> f =\n      circuitBreaker.callWithCircuitBreaker(\n          () -> Futures.future(() -> startInstance(credentials), executionContext));\n\n  final PartialFunction<Throwable, Future<Instance>> recovery =\n      new PFBuilder<Throwable, Future<Instance>>()\n          .match(\n              AmazonClientException.class,\n              AmazonClientException::isRetryable,\n              ex -> startInstanceAsync(credentials))\n          .build();\n\n  return f.recoverWith(recovery, executionContext);\n}\n代码清单 14-3 通过桥接客户端代码执行亚马逊的异步客户端\npublic Future<RunInstancesResult> runInstancesAsync(\n    final RunInstancesRequest request, final AmazonEC2Async client) {\n\n  final Promise<RunInstancesResult> promise = Futures.promise();\n  client.runInstancesAsync(\n      request,\n      new AsyncHandler<RunInstancesRequest, RunInstancesResult>() {\n\n        @Override\n        public void onSuccess(RunInstancesRequest request, RunInstancesResult result) {\n          promise.success(result);\n        }\n\n        @Override\n        public void onError(Exception exception) {\n          promise.failure(exception);\n        }\n      });\n  return promise.future();\n}\n代码清单 14-4 关闭 EC2 实例\npublic Future<TerminateInstancesResult> terminateInstancesAsync(\n    final AmazonEC2Client client, final Instance... instances) {\n\n  final List<String> ids =\n      Arrays.stream(instances).map(Instance::getInstanceId).collect(Collectors.toList());\n  final TerminateInstancesRequest request = new TerminateInstancesRequest(ids);\n\n  final Future<TerminateInstancesResult> f =\n      circuitBreaker.callWithCircuitBreaker(\n          () -> Futures.future(() -> client.terminateInstances(request), executionContext));\n\n  final PartialFunction<Throwable, Future<TerminateInstancesResult>> recovery =\n      new PFBuilder<Throwable, Future<TerminateInstancesResult>>()\n          .match(\n              AmazonClientException.class,\n              AmazonClientException::isRetryable,\n              ex -> terminateInstancesAsync(client, instances))\n          .build();\n\n  return f.recoverWith(recovery, executionContext);\n}\n代码清单 14-5 执行组件和看作工作者节点的 Actor 通信\nclass WorkerNode extends AbstractActor {\n  private final Cancellable checkTimer;\n\n  public WorkerNode(final InetAddress address, final Duration checkInterval) {\n    checkTimer =\n        getContext()\n            .getSystem()\n            .getScheduler()\n            .schedule(\n                checkInterval,\n                checkInterval,\n                self(),\n                DoHealthCheck.INSTANCE,\n                getContext().dispatcher(),\n                self());\n  }\n\n  @Override\n  public Receive createReceive() {\n    final List<WorkerNodeMessage> msgs = new ArrayList<>();\n    return receiveBuilder()\n        .match(WorkerNodeMessage.class, msgs::add)\n        .match(\n            DoHealthCheck.class,\n            dhc -> {\n              /* perform check */\n            })\n        .match(\n            Shutdown.class,\n            s -> {\n              msgs.forEach(\n                  msg ->\n                      msg.replyTo()\n                          .tell(new WorkerCommandFailed(\"shutting down\", msg.id()), self()));\n              /* ask Resource Pool to shut down this INSTANCE */\n            })\n        .match(\n            WorkerNodeReady.class,\n            wnr -> {\n              /* send msgs to the worker */\n              getContext().become(initialized());\n            })\n        .build();\n  }\n\n  private Receive initialized() {\n    /* forward commands and deal with responses from worker node */\n    // ...\n    return null;\n  }\n\n  @Override\n  public void postStop() {\n    checkTimer.cancel();\n  }\n}","title":"14.1 资源封装模式"},{"location":"/chapter-14/index.html#14-2-资源借贷模式","text":"代码清单 14-6 分离资源和任务的管理\nclass WorkerNodeForExecution extends AbstractActor {\n\n  @Override\n  public Receive createReceive() {\n    List<WorkerNodeMessage> msgs = new ArrayList<>();\n    return receiveBuilder()\n        .match(WorkerNodeMessage.class, msgs::add)\n        .match(\n            Shutdown.class,\n            s -> {\n              msgs.forEach(\n                  msg -> {\n                    WorkerCommandFailed failMsg =\n                        new WorkerCommandFailed(\"shutting down\", msg.id());\n                    msg.replyTo().tell(failMsg, self());\n                  });\n            })\n        .match(WorkerNodeReady.class, wnr -> getContext().become(initialized()))\n        .build();\n  }\n\n  private Receive initialized() {\n    /* forward commands and deal with responses from worker node */\n    // ...\n    return null;\n  }\n}\n\nclass WorkNodeForResourcePool extends AbstractActor {\n  private final Cancellable checkTimer;\n\n  public WorkNodeForResourcePool(InetAddress address, FiniteDuration checkInterval) {\n    checkTimer =\n        getContext()\n            .system()\n            .scheduler()\n            .schedule(\n                checkInterval,\n                checkInterval,\n                self(),\n                DoHealthCheck.INSTANCE,\n                getContext().dispatcher(),\n                self());\n  }\n\n  @Override\n  public Receive createReceive() {\n    return receiveBuilder()\n        .match(\n            DoHealthCheck.class,\n            dhc -> {\n              /* perform check */\n            })\n        .match(\n            Shutdown.class,\n            s -> {\n              /* Cleans up this resource */\n            })\n        .build();\n  }\n\n  @Override\n  public void postStop() {\n    checkTimer.cancel();\n  }\n}","title":"14.2 资源借贷模式"},{"location":"/chapter-14/index.html#14-3-复杂命令模式","text":"代码清单 14-7 批处理作业的基本构成\npublic interface ProcessingLogic {\n  PartialResult process(Stream<DataElement> input);\n}\n\n//\npublic interface MergeLogic {\n  Result merge(Collection<PartialResult> partialResults);\n}\n\npublic class BatchJob {\n  public final String dataSelector;\n  public final ProcessingLogic processingLogic;\n  public final MergeLogic mergeLogic;\n\n  public BatchJob(String dataSelector, ProcessingLogic processingLogic, MergeLogic mergeLogic) {\n    this.dataSelector = dataSelector;\n    this.processingLogic = processingLogic;\n    this.mergeLogic = mergeLogic;\n  }\n\n  public BatchJob withDataSelector(String selector) {\n    return new BatchJob(selector, processingLogic, mergeLogic);\n  }\n}\n代码清单 14-8 通过调用Nashorn JavaScript脚本引擎执行处理逻辑\npublic class PartSuccess implements PartialResult {\n  public final int value;\n\n  public PartSuccess(int value) {\n    this.value = value;\n  }\n\n  @Override\n  public String toString() {\n    return \"ResultSuccess(\" + value + \")\";\n  }\n}\n\npublic class PartFailure implements PartialResult {\n  public final Throwable failure;\n\n  public PartFailure(Throwable failure) {\n    this.failure = failure;\n  }\n\n  @Override\n  public String toString() {\n    return \"ResultFailure(\" + failure.getMessage() + \")\";\n  }\n}\n\npublic class BatchJobJS {\n  public final String dataSelector;\n  public final String processingLogic;\n  public final String mergeLogic;\n\n  public BatchJobJS(String dataSelector, String processingLogic, String mergeLogic) {\n    this.dataSelector = dataSelector;\n    this.processingLogic = processingLogic;\n    this.mergeLogic = mergeLogic;\n  }\n\n  public BatchJobJS withDataSelector(String selector) {\n    return new BatchJobJS(selector, processingLogic, mergeLogic);\n  }\n}\n\npublic class WorkerJS {\n  private static final ScriptEngine ENGINE = new ScriptEngineManager().getEngineByName(\"nashorn\");\n\n  public PartialResult runJob(final BatchJobJS job) {\n    final Invocable invocable = (Invocable) ENGINE;\n\n    try {\n      ENGINE.eval(job.processingLogic);\n      final Stream<DataElement> input = provideData(job.dataSelector);\n      final PartialResult result = (PartialResult) invocable.invokeFunction(\"process\", input);\n      return result;\n    } catch (Exception e) {\n      return new PartFailure(e);\n    }\n  }\n\n  private Stream<DataElement> provideData(String selector) {\n    /* fetch data from persistent storage in streaming fashion */\n    return Stream.of(1, 2, 3).map(DataElement::new);\n  }\n}\njob.js\nvar PartSuccess = Java.type(\n    'chapter14.ComplexCommand.PartSuccess');\n\nvar process = function (input) {\n    // 'input' is a Java 8 Stream\n    var value = input.count();\n    return new PartSuccess(value);\n}\n代码清单 14-9 外部 DSL 使用了不同于宿主编程语言的语法\nFOREACH Car (_, _, year, price)\nSELECT year ? 1950 && year < 1960\nMEDIAN OF price\nREMEMBER AS p\n\nFOREACH Car (make, model, _, price)\nSELECT price > p\nDISTINCT VALUES OF (make, model)\nRETURN AS RESULT\n代码清单 14-10 内部 DSL\npublic static void akkaStreamDSL() {\n  final RunnableGraph<CompletionStage<Long>> p =\n      Source.<DataElement>empty()\n          .filter(new InRange(\"year\", 1950, 1960))\n          .toMat(Sink.fold(0L, new Median<>(\"price\")), Keep.right());\n\n  Source.<DataElement>empty()\n      .map(new Inject<>(p, \"p\"))\n      .filter(new Filter(\"price > p\"))\n      .to(\n          Sink.fold(\n              Collections.emptySet(), new DistinctValues<Pair<String, String>>(\"make\", \"model\")));\n}","title":"14.3 复杂命令模式"},{"location":"/chapter-14/index.html#14-5-托管阻塞模式","text":"代码清单 14-11 维护一个私有的ExecutorService\npublic enum AccessRights {\n  READ_JOB_STATUS,\n  SUBMIT_JOB;\n\n  public static final AccessRights[] EMPTY = new AccessRights[] {};\n}\n\npublic class CheckAccess {\n  public final String username;\n  public final String credentials;\n  public final AccessRights[] rights;\n  public final ActorRef replyTo;\n\n  public CheckAccess(\n      String username, String credentials, AccessRights[] rights, ActorRef replyTo) {\n    this.username = username;\n    this.credentials = credentials;\n    this.rights = rights;\n    this.replyTo = replyTo;\n  }\n}\n\npublic class CheckAccessResult {\n  public final String username;\n  public final String credentials;\n  public final AccessRights[] rights;\n\n  public CheckAccessResult(CheckAccess ca, AccessRights[] rights) {\n    this.username = ca.username;\n    this.credentials = ca.credentials;\n    this.rights = rights;\n  }\n}\n\npublic class AccessService extends AbstractActor {\n  private final ExecutorService pool;\n  private final DataSource db;\n\n  public AccessService(DataSource db, int poolSize, int queueSize) {\n    this.db = db;\n    pool =\n        new ThreadPoolExecutor(\n            0,\n            poolSize,\n            60,\n            SECONDS,\n            new LinkedBlockingDeque<>(queueSize),\n            new NamedPoolThreadFactory(\"ManagedBlocking-\" + getSelf().path().name(), true));\n  }\n\n  @Override\n  public Receive createReceive() {\n    final ActorRef self = self();\n    return ReceiveBuilder.create()\n        .match(\n            CheckAccess.class,\n            ca -> {\n              try {\n                pool.execute(() -> checkAccess(db, ca, self));\n              } catch (RejectedExecutionException e) {\n                ca.replyTo.tell(new CheckAccessResult(ca, AccessRights.EMPTY), self);\n              }\n            })\n        .build();\n  }\n\n  @Override\n  public void postStop() {\n    pool.shutdownNow();\n  }\n\n  private static void checkAccess(DataSource db, CheckAccess ca, ActorRef self) {\n    try (Connection conn = db.getConnection()) {\n      final ResultSet result = conn.createStatement().executeQuery(\"<get access rights>\");\n      final List<AccessRights> rights = new LinkedList<>();\n      while (result.next()) {\n        rights.add(AccessRights.valueOf(result.getString(0)));\n      }\n      ca.replyTo.tell(new CheckAccessResult(ca, rights.toArray(AccessRights.EMPTY)), self);\n    } catch (Exception e) {\n      ca.replyTo.tell(new CheckAccessResult(ca, AccessRights.EMPTY), self);\n    }\n  }\n}","title":"14.5 托管阻塞模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"在这一章中，我们将探讨一些存在于反应式组件之间最基本的通信模式：具体而言，我们将讨论消息是如何在它们之间流动的。在第10章中，我们讨论了理论背景，提到了系统中的通信路径设计对于系统的成功来说至关重要——无论是对现实世界的组织，还是反应式应用程序。","title":"第15章——消息流模式"},{"location":"/chapter-15/index.html#15-1-请求-响应模式","text":"代码清单15-1 服务器向发起请求的地址发送响应\npublic class Server {\n  static final int SERVER_PORT = 8888;\n\n  public static void main(String[] args) throws IOException {\n    // bind a socket for receiving packets\n    try (final DatagramSocket socket = new DatagramSocket(SERVER_PORT)) {\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet1 = new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet1);\n\n      final SocketAddress sender = packet1.getSocketAddress();\n      System.out.println(\"server: received \" + new String(packet1.getData()));\n      System.out.println(\"server: sender was \" + sender);\n\n      // send response back\n      final byte[] response = \"got it!\".getBytes();\n      final DatagramPacket packet2 = new DatagramPacket(response, response.length, sender);\n      socket.send(packet2);\n    }\n  }\n}\n代码清单15-2 客户端发送一个请求，然后阻塞直到接收到服务器的响应\npublic class Client {\n  public static void main(String[] args) throws IOException {\n    // get local socket with random port\n    try (final DatagramSocket socket = new DatagramSocket()) {\n\n      // send message to server\n      final byte[] request = \"hello\".getBytes();\n      final SocketAddress serverAddress = new InetSocketAddress(\"localhost\", SERVER_PORT);\n      final DatagramPacket packet1 = new DatagramPacket(request, request.length, serverAddress);\n      socket.send(packet1);\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet2 = new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet2);\n\n      final SocketAddress sender = packet2.getSocketAddress();\n      System.out.println(\"client: received \" + new String(packet2.getData()));\n      System.out.println(\"client: sender was \" + sender);\n    }\n  }\n}\nServer 的输出结果\nserver: received hello\nserver: sender was /127.0.0.1:55589\nClient 的可能输出结果\nclient: received got it!\nclient: sender was /127.0.0.1:8888\nHTTP Request Header\nGET /request?msg=hello HTTP/1.1\nHost: client-interface.our.application.domain\nAccept: application/json\nHTTP Response Header\nHTTP/1.1 200 OK\n...\nContent-Type: application/json\nContent-Length: 22\n{\"response\":\"got it!\"}\n代码清单15-3 使用Akka UntypedActor 来建模请求——响应模式\nobject RequestResponseActors {\n\n  final case class Request(msg: String)\n\n  final case class Response(msg: String)\n\n  class Responder extends Actor {\n    def receive: Receive = {\n      case Request(msg) ⇒\n        println(s\"got request: $msg\")\n        sender() ! Response(\"got it!\")\n    }\n  }\n\n  class Requester(responder: ActorRef) extends Actor {\n    responder ! Request(\"hello\")\n\n    def receive: Receive = {\n      case Response(msg) ⇒\n        println(s\"got response: $msg\")\n        context.system.terminate()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sys = ActorSystem(\"ReqRes\")\n    val responder = sys.actorOf(Props[Responder], \"responder\")\n    val requester = sys.actorOf(Props(new Requester(responder)), \"requester\")\n  }\n\n}\n运行结果\ngot request: hello\ngot response: got it!\n代码清单15-4 在请求消息中显式地包含响应地址\nobject RequestResponseTypedActors {\n\n  final case class Request(msg: String, replyTo: ActorRef[Response])\n\n  final case class Response(msg: String)\n\n  val responder: Behavior[Request] =\n    Static {\n      case Request(msg, replyTo) ⇒\n        println(s\"got request: $msg\")\n        replyTo ! Response(\"got it!\")\n    }\n\n  def requester(responder: ActorRef[Request]): Behavior[Response] =\n    SelfAware { self ⇒\n      responder ! Request(\"hello\", self)\n      Total {\n        case Response(msg) ⇒\n          println(s\"got response: $msg\")\n          Stopped\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(\"ReqResTyped\", ContextAware[Unit] { ctx ⇒\n      val res = ctx.spawn(responder, \"responder\")\n      val req = ctx.watch(ctx.spawn(requester(res), \"requester\"))\n      Full {\n        case Sig(_, Terminated(`req`)) ⇒ Stopped\n      }\n    })\n  }\n}\n代码清单15-5 基于单向消息传递的请求——响应模式\nvar amqp = require('amqplib/callback_api');\n\namqp.connect('amqp://localhost', function (err, conn) {\n    conn.createChannel(function (err, ch) {\n        var q = 'rpc_queue';\n        ch.assertQueue(q, {durable: false});\n        ch.prefetch(1);\n        ch.consume(q, function reply(msg) {\n            console.log(\"got request: %s\", msg.content.toString());\n            ch.sendToQueue(msg.properties.replyTo,\n                new Buffer('got it!'),\n                {correlationId: msg.properties.correlationId});\n            ch.ack(msg);\n        });\n    });\n});\n代码清单15-6 监听与原始请求具有相同的关联ID的响应\nvar uuid = require('node-uuid');\n\namqp.connect('amqp://localhost', function (err, conn) {\n    conn.createChannel(function (err, ch) {\n        ch.assertQueue('responses', {}, function (err, q) {\n            var corr = uuid.v1();\n            ch.consume(q.queue, function (msg) {\n                if (msg.properties.correlationId === corr) {\n                    console.log('got response: %s', msg.content.toString());\n                    setTimeout(function () {\n                        conn.close();\n                        process.exit(0)\n                    }, 500);\n                }\n            }, {noAck: true});\n            ch.sendToQueue('rpc_queue',\n                new Buffer('hello'),\n                {correlationId: corr, replyTo: q.queue});\n        });\n    });\n});","title":"15.1 请求——响应模式"},{"location":"/chapter-15/index.html#15-2-消息自包含模式","text":"SMTP\nS: 220 mailhost.example.com ESMTP Postfix\nC: HELO alice-workstation.example.com\nS: 250 Hello alice-workstation.example.com\nC: MAIL FROM:<alice@example.com>\nS: 250 Ok\nC: RCPT TO:<bob@example.com>\nS: 250 Ok\nC: DATA\nS: 354 End data with <CR><LF>.<CR><LF>\nC: From: \"Alice\" <alice@example.com>\nC: To: \"Bob\" <bob@example.com>\nC: Date: Fri, 23 October 2015 10:34:12 +0200\nC: Subject: lunch\nC:\nC: Hi Bob,\nC:\nC: sorry, I cannot make it, something else came up.\nC:\nC: Regards, Alice\nC: .\nS: 250 Ok, queued as 4567876345\nC: QUIT\nS: 221 Bye\n代码清单15-7 封装了多次 SMTP 交换所需要的信息\nfinal case class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  body:          String,\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])\nfinal case class SendEmailResult(\n  correlationID: UUID,\n  status:        StatusCode,\n  explanation:   Option[String]) extends Result\n代码清单15-8 分离电子邮件主体，使得其可以按需投递\nfinal case class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])(body: Source[String]) extends StreamedRequest {\n  override def payload: Source[String] = body\n}\n代码清单15-9 允许邮件主体可以被接收者拉取\nfinal case class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  bodyLocation:  URL,\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])","title":"15.2 消息自包含模式"},{"location":"/chapter-15/index.html#15-3-询问模式","text":"代码清单15-10 请求启动验证过程的简单协议\nfinal case class StartVerificationProcess(\n  userEmail: String,\n  replyTo:   ActorRef[VerificationProcessResponse]) extends MyCommands\n\nsealed trait VerificationProcessResponse\n\nfinal case class VerificationProcessStarted(userEmail: String) extends VerificationProcessResponse\n\nfinal case class VerificationProcessFailed(userEmail: String) extends VerificationProcessResponse\n代码清单15-11 一个转发结果的匿名子Actor\ndef withChildActor(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx: ActorContext[StartVerificationProcess] ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val childActor = ctx.spawnAnonymous(FullTotal[Result] {\n          case Sig(ctx, PreStart) ⇒\n            ctx.setReceiveTimeout(5.seconds, ReceiveTimeout)\n            Same\n          case Msg(_, ReceiveTimeout) ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.OK, _)) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            replyTo ! VerificationProcessStarted(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.Failed, explanation)) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(wrongID, _, _)) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            Same\n        })\n        val request = SendEmail(\"verification@example.com\", List(userEmail),\n          constructBody(userEmail, corrID), corrID, childActor)\n        emailGateway ! request\n    }\n  }\n代码清单15-12 由询问模式所产生的Future，并进行了转换\ndef withAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    implicit val timeout: Timeout = Timeout(5.seconds)\n    import ctx.executionContext\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val response: Future[SendEmailResult] =\n          emailGateway ? (SendEmail(\n            \"verification@example.com\",\n            List(userEmail),\n            constructBody(userEmail, corrID), corrID, _))\n        response.map {\n          case SendEmailResult(`corrID`, StatusCode.OK, _) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            VerificationProcessStarted(userEmail)\n          case SendEmailResult(`corrID`, StatusCode.Failed, explanation) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            VerificationProcessFailed(userEmail)\n          case SendEmailResult(wrongID, _, _) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            VerificationProcessFailed(userEmail)\n        }.recover {\n          case _: AskTimeoutException ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            VerificationProcessFailed(userEmail)\n        }.foreach(result ⇒ replyTo ! result)\n    }\n  }\n代码清单15-13 不使用内置支持实现询问模式\ndef withoutAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware[MyCommands] { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    var statusMap = Map.empty[UUID, (String, ActorRef[VerificationProcessResponse])]\n    val adapter = ctx.spawnAdapter((s: SendEmailResult) ⇒\n      MyEmailResult(s.correlationID, s.status, s.explanation))\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val request = SendEmail(\"verification@example.com\", List(userEmail),\n          constructBody(userEmail, corrID), corrID, adapter)\n        emailGateway ! request\n        statusMap += corrID -> (userEmail, replyTo)\n        ctx.schedule(5.seconds, ctx.self, MyEmailResult(\n          corrID, StatusCode.Failed, Some(\"timeout\")))\n      case MyEmailResult(correlationID, status, explanation) ⇒\n        statusMap.get(correlationID) match {\n          case None ⇒\n            log.error(\n              \"received SendEmailResult for unknown correlation ID {}\",\n              correlationID)\n          case Some((userEmail, replyTo)) ⇒\n            status match {\n              case StatusCode.OK ⇒\n                log.debug(\n                  \"successfully started the verification process for {}\",\n                  userEmail)\n                replyTo ! VerificationProcessStarted(userEmail)\n              case StatusCode.Failed ⇒\n                log.info(\n                  \"failed to start the verification process for {}: {}\",\n                  userEmail, explanation)\n                replyTo ! VerificationProcessFailed(userEmail)\n            }\n            statusMap -= correlationID\n        }\n    }\n  }.narrow[StartVerificationProcess]","title":"15.3 询问模式"},{"location":"/chapter-15/index.html#15-5-聚合器模式","text":"代码清单15-14 使用for推导式来聚合三个Future表达式的结果。\ndef futureFrontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    import ctx.executionContext\n    implicit val timeout: Timeout = Timeout(1.second)\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val cssFuture =\n          (themes ? (GetTheme(user, _: ActorRef[ThemeResult])))\n            .map(_.css)\n            .recover {\n              case _: AskTimeoutException ⇒ \"default.css\"\n            }\n        val personalNewsFuture =\n          (personalNews ? (GetPersonalNews(\n            user,\n            _: ActorRef[PersonalNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        val topNewsFuture =\n          (topNews ? (GetTopNews(_: ActorRef[TopNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        for {\n          css ← cssFuture\n          personalNews ← personalNewsFuture\n          topNews ← topNewsFuture\n        } {\n          val topSet = topNews.toSet\n          val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n          replyTo ! FrontPageResult(user, css, allNews)\n        }\n    }\n  }\n代码清单15-15 使用子Actor替代Future组合子的使用\nprivate def pf(p: PartialFunction[AnyRef, Unit]): p.type = p\n\ndef frontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val childRef = ctx.spawnAnonymous(Deferred { () ⇒\n          val builder = new FrontPageResultBuilder(user)\n          Partial[AnyRef](\n            pf {\n              case ThemeResult(css)         ⇒ builder.addCSS(css)\n              case PersonalNewsResult(news) ⇒ builder.addPersonalNews(news)\n              case TopNewsResult(news)      ⇒ builder.addTopNews(news)\n              case ReceiveTimeout           ⇒ builder.timeout()\n            } andThen { _ ⇒\n              if (builder.isComplete) {\n                replyTo ! builder.result\n                Stopped\n              } else Same\n            })\n        })\n        themes ! GetTheme(user, childRef)\n        personalNews ! GetPersonalNews(user, childRef)\n        topNews ! GetTopNews(childRef)\n        ctx.schedule(1.second, childRef, ReceiveTimeout)\n    }\n  }\n代码清单15-16 使用一个构建器来更加直接地表达领域模型\nclass FrontPageResultBuilder(user: String) {\n  private var css: Option[String] = None\n  private var personalNews: Option[List[String]] = None\n  private var topNews: Option[List[String]] = None\n\n  def addCSS(css: String): Unit = this.css = Option(css)\n\n  def addPersonalNews(news: List[String]): Unit =\n    this.personalNews = Option(news)\n\n  def addTopNews(news: List[String]): Unit =\n    this.topNews = Option(news)\n\n  def timeout(): Unit = {\n    if (css.isEmpty) css = Some(\"default.css\")\n    if (personalNews.isEmpty) personalNews = Some(Nil)\n    if (topNews.isEmpty) topNews = Some(Nil)\n  }\n\n  def isComplete: Boolean = css.isDefined &&\n    personalNews.isDefined && topNews.isDefined\n\n  def result: FrontPageResult = {\n    val topSet = topNews.get.toSet\n    val allNews = topNews.get :::\n      personalNews.get.filterNot(topSet.contains)\n    FrontPageResult(user, css.get, allNews)\n  }\n}\n代码清单15-17 添加第4个服务，降低了代码的可读性\nval overrideFuture =\n  (overrides ? (GetOverride(_: ActorRef[OverrideResult])))\n    .recover {\n      case _: AskTimeoutException ⇒ NoOverride\n    }\nfor {\n  css ← cssFuture\n  personalNews ← personalNewsFuture\n  topNews ← topNewsFuture\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒\n    val topSet = topNews.toSet\n    val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n    replyTo ! FrontPageResult(user, css, allNews)\n  case _ ⇒ // nothing to do here\n}\nfor {\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒ // nothing to do here\n  case Override(css, news) ⇒\n    replyTo ! FrontPageResult(user, css, news)\n}","title":"15.5 聚合器模式"},{"location":"/chapter-15/index.html#15-7-业务握手协议-又名可靠投递模式-","text":"代码清单15-18 使用Actor实现上面的（信息）交换\nfinal case class ChangeBudget(amount: BigDecimal, replyTo: ActorRef)\n\ncase object ChangeBudgetDone\n\nfinal case class CannotChangeBudget(reason: String)\n\nclass Sam(\n  alice:  ActorRef,\n  bob:    ActorRef,\n  amount: BigDecimal) extends Actor {\n  def receive: Receive = talkToAlice()\n\n  def talkToAlice(): Receive = {\n    alice ! ChangeBudget(-amount, self)\n    context.setReceiveTimeout(1.second)\n\n    LoggingReceive {\n      case ChangeBudgetDone           ⇒ context.become(talkToBob())\n      case CannotChangeBudget(reason) ⇒ context.stop(self)\n      case ReceiveTimeout             ⇒ alice ! ChangeBudget(-amount, self)\n    }\n  }\n\n  def talkToBob(): Receive = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n}\n\nclass Alice extends Actor {\n  private var budget: BigDecimal = 10\n  private var alreadyDone: Set[ActorRef] = Set.empty\n\n  def receive = LoggingReceive {\n    case ChangeBudget(amount, replyTo) if alreadyDone(replyTo) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo) if amount + budget > 0 ⇒\n      budget += amount\n      alreadyDone += replyTo\n      context.watch(replyTo)\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(_, replyTo) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case Terminated(saga) ⇒\n      alreadyDone -= saga\n  }\n}\n代码清单15-19 向预算消息添加持久性\nfinal case class AliceConfirmedChange(deliveryId: Long)\n\nfinal case class AliceDeniedChange(deliveryId: Long)\n\nclass PersistentSam(\n  alice:                      ActorPath,\n  bob:                        ActorPath,\n  amount:                     BigDecimal,\n  override val persistenceId: String)\n  extends PersistentActor with AtLeastOnceDelivery with ActorLogging {\n\n  def receiveCommand: Receive = Actor.emptyBehavior\n\n  override def preStart(): Unit = {\n    context.become(talkToAlice())\n  }\n\n  def talkToAlice(): Receive = {\n    log.debug(\"talking to Alice\")\n    var deliveryId: Long = 0\n    deliver(alice)(id ⇒ {\n      deliveryId = id\n      ChangeBudget(-amount, self, persistenceId)\n    })\n\n    LoggingReceive({\n      case ChangeBudgetDone ⇒\n        persist(AliceConfirmedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.become(talkToBob())\n        }\n      case CannotChangeBudget(reason) ⇒\n        persist(AliceDeniedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.stop(self)\n        }\n    }: Receive)\n  }\n\n  def talkToBob(): Receive = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n\n  def receiveRecover = LoggingReceive {\n    case AliceConfirmedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.become(talkToBob())\n    case AliceDeniedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.stop(self)\n  }\n}\n代码清单15-20 Alice Actor的持久化版本\nfinal case class BudgetChanged(amount: BigDecimal, persistenceId: String)\n\ncase object CleanupDoneList\n\nfinal case class ChangeDone(persistenceId: String)\n\nclass PersistentAlice extends PersistentActor with ActorLogging {\n  def persistenceId: String = \"Alice\"\n\n  private implicit val mat: ActorMaterializer = ActorMaterializer()\n\n  import context.dispatcher\n\n  private var alreadyDone: Set[String] = Set.empty\n  private var budget: BigDecimal = 10\n\n  private val cleanupTimer: Cancellable = context.system.scheduler.\n    schedule(1.hour, 1.hour, self, CleanupDoneList)\n\n  def receiveCommand = LoggingReceive {\n    case ChangeBudget(amount, replyTo, id) if alreadyDone(id) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo, id) if amount + budget > 0 ⇒\n      persist(BudgetChanged(amount, id)) { ev ⇒\n        budget += ev.amount\n        alreadyDone += ev.persistenceId\n        replyTo ! ChangeBudgetDone\n      }\n    case ChangeBudget(_, replyTo, _) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case CleanupDoneList ⇒\n      val journal = PersistenceQuery(context.system)\n        .readJournalFor[LeveldbReadJournal](LeveldbReadJournal.Identifier)\n      for (persistenceId ← alreadyDone) {\n        val stream = journal\n          .currentEventsByPersistenceId(persistenceId)\n          .map(_.event)\n          .collect {\n            case AliceConfirmedChange(_) ⇒ ChangeDone(persistenceId)\n          }\n        stream.runWith(Sink.head).pipeTo(self)\n      }\n    case ChangeDone(id) ⇒\n      persist(ChangeDone(id)) { ev ⇒\n        alreadyDone -= ev.persistenceId\n      }\n  }\n\n  def receiveRecover = LoggingReceive {\n    case BudgetChanged(amount, id) ⇒\n      budget += amount\n      alreadyDone += id\n    case ChangeDone(id) ⇒\n      alreadyDone -= id\n  }\n\n  override def postStop(): Unit = {\n    cleanupTimer.cancel()\n  }\n}","title":"15.7 业务握手协议（又名可靠投递模式）"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"在前面的章节里，你学会了如何将系统拆分成较小的部分，以及这些部分之间如何通信以解决较大的任务。有一个我们到目前为止尚未提及的角度：除了确定谁与谁交互之外，你必须同样考虑通信的时效性。为了让你的系统在不同的负载下都更具有回弹性，你需要能够阻止组件因为过量的请求速率而不可控制地失败的机制。为此，这一章介绍了下面四种基本模式。","title":"第16章——流控制模式"},{"location":"/chapter-16/index.html#16-1-拉取模式","text":"代码清单16-1 在拉取输入的工作者内部处理昂贵的计算\nclass Worker(manager: ActorRef) extends Actor {\n  private val mc = new MathContext(100, RoundingMode.HALF_EVEN)\n  private val plus = BigDecimal(1, mc)\n  private val minus = BigDecimal(-1, mc)\n\n  private var requested = 0\n\n  def request(): Unit =\n    if (requested < 5) {\n      manager ! WorkRequest(self, 10)\n      requested += 10\n    }\n\n  request()\n\n  def receive: Receive = {\n    case Job(id, data, replyTo) ⇒\n      requested -= 1\n      request()\n      val sign = if ((data & 1) == 1) plus else minus\n      val result = sign / data\n      replyTo ! JobResult(id, result)\n  }\n}\n代码清单16-2 按工作者所请求的数目给它们提供任务\nclass Manager extends Actor {\n\n  private val works: Iterator[Job] =\n    Iterator from 1 map (x ⇒ Job(x, x, self)) take 1000000\n\n  private val aggregator: (BigDecimal, BigDecimal) ⇒ BigDecimal = (x: BigDecimal, y: BigDecimal) ⇒ x + y\n  private val mc = new MathContext(10000, RoundingMode.HALF_EVEN)\n  private var approximation = BigDecimal(0, mc)\n\n  private var outstandingWork = 0\n\n  (1 to 8) foreach (_ ⇒ context.actorOf(Props(new Worker(self))))\n\n  def receive: Receive = {\n    case WorkRequest(worker, items) ⇒\n      works.toStream.take(items).foreach { job ⇒\n        worker ! job\n        outstandingWork += 1\n      }\n    case JobResult(id, report) ⇒\n      approximation = aggregator(approximation, report)\n      outstandingWork -= 1\n      if (outstandingWork == 0 && works.isEmpty) {\n        println(\"final result: \" + approximation)\n        context.system.terminate()\n      }\n  }\n}","title":"16.1 拉取模式"},{"location":"/chapter-16/index.html#16-2-托管队列模式","text":"代码清单16-3 管理一个工作队列以对过载作出反应\nclass Manager extends Actor {\n\n  private var workQueue: Queue[Job] = Queue.empty[Job]\n  private var requestQueue: Queue[WorkRequest] = Queue.empty[WorkRequest]\n\n  (1 to 8) foreach (_ ⇒ context.actorOf(Props(new Worker(self))))\n\n  def receive: Receive = {\n    case job @ Job(id, _, replyTo) ⇒\n      if (requestQueue.isEmpty) {\n        if (workQueue.size < 1000) workQueue :+= job\n        else replyTo ! JobRejected(id)\n      } else {\n        val WorkRequest(worker, items) = requestQueue.head\n        worker ! job\n        if (items > 1) {\n          worker ! DummyWork(items - 1)\n        }\n        requestQueue = requestQueue.drop(1)\n      }\n    case wr @ WorkRequest(worker, items) ⇒\n      if (workQueue.isEmpty) {\n        requestQueue :+= wr\n      } else {\n        workQueue.iterator.take(items).foreach(job ⇒ worker ! job)\n        val sent = Math.min(workQueue.size, items)\n        if (sent < items) {\n          worker ! DummyWork(items - sent)\n        }\n        workQueue = workQueue.drop(items)\n      }\n  }\n}\nQueuePattern.scala\nclass Worker(manager: ActorRef) extends Actor {\n  private val plus = BigDecimal(1, mc)\n  private val minus = BigDecimal(-1, mc)\n\n  private var requested = 0\n\n  def request(): Unit =\n    if (requested < 5) {\n      manager ! WorkRequest(self, 10)\n      requested += 10\n    }\n\n  request()\n\n  def receive: Receive = {\n    case Job(id, data, replyTo) ⇒\n      requested -= 1\n      request()\n      val sign = if ((data & 1) == 1) plus else minus\n      val result = sign / data\n      replyTo ! JobResult(id, result)\n    case DummyWork(count) ⇒\n      requested -= count\n      request()\n  }\n}","title":"16.2 托管队列模式"},{"location":"/chapter-16/index.html#16-3-丢弃模式","text":"DropPattern.scala\nprivate val queueThreshold = 1000\nprivate val dropThreshold = 1384\n\ndef random: ThreadLocalRandom = ThreadLocalRandom.current\n\ndef shallEnqueue(atSize: Int): Boolean =\n  (atSize < queueThreshold) || {\n    val dropFactor = (atSize - queueThreshold) >> 6\n    random.nextInt(dropFactor + 2) == 0\n  }\nDropPattern.scala\ncase job @ Job(id, _, replyTo) ⇒\n  if (requestQueue.isEmpty) {\n    val atSize = workQueue.size\n    if (shallEnqueue(atSize)) {\n      workQueue :+= job\n    } else if (atSize < dropThreshold) {\n      replyTo ! JobRejected(id)\n    }\n  } else {\nDropPatternWithProtection.scala\nprivate final case class WorkEnvelope(job: Job) {\n  @volatile var consumed = false\n}\n\nprivate class IncomingQueue(manager: ActorRef) extends Actor {\n  private var workQueue: Queue[WorkEnvelope] = Queue.empty[WorkEnvelope]\n\n  def receive: Receive = {\n    case job: Job ⇒\n      workQueue = workQueue.dropWhile(_.consumed)\n      if (workQueue.size < 1000) {\n        val envelope = WorkEnvelope(job)\n        workQueue :+= envelope\n        manager ! envelope\n      }\n  }\n}","title":"16.3 丢弃模式"},{"location":"/chapter-16/index.html#16-4-限流模式","text":"代码清单16-4 根据特定速率使用令牌桶来拉取工作\nclass CalculatorClient(\n  workSource:    ActorRef,\n  calculator:    ActorRef,\n  ratePerSecond: Long,\n  bucketSize:    Int,\n  batchSize:     Int) extends Actor {\n  def now(): Long = System.nanoTime()\n\n  private val nanoSecondsBetweenTokens: Long =\n    1000000000L / ratePerSecond\n\n  private var tokenBucket: Int = bucketSize\n  private var lastTokenTime: Long = now()\n\n  def refillBucket(time: Long): Unit = {\n    val accrued = (time -\n      lastTokenTime) * ratePerSecond / 1000000000L\n    if (tokenBucket + accrued >= bucketSize) {\n      tokenBucket = bucketSize\n      lastTokenTime = time\n    } else {\n      tokenBucket += accrued.toInt\n      lastTokenTime += accrued * nanoSecondsBetweenTokens\n    }\n  }\n\n  def consumeToken(time: Long): Unit = {\n    // always refill first since we do it upon activity and not scheduled\n    refillBucket(time)\n    tokenBucket -= 1\n  }\n\n  /**\n   * second part: managing the pull pattern’s demand\n   */\n  private var requested = 0\n\n  def request(time: Long): Unit =\n    if (tokenBucket - requested >= batchSize) {\n      sendRequest(time, batchSize)\n    } else if (requested == 0) {\n      if (tokenBucket > 0) {\n        sendRequest(time, tokenBucket)\n      } else {\n        val timeForNextToken =\n          lastTokenTime + nanoSecondsBetweenTokens - time\n        context.system.scheduler\n          .scheduleOnce(\n            timeForNextToken.nanos,\n            workSource,\n            WorkRequest(self, 1))(context.dispatcher)\n        requested = 1\n        if (Debug) {\n          println(s\"$time: request(1) scheduled for ${time + timeForNextToken}\")\n        }\n      }\n    } else if (Debug) {\n      println(s\"$time: not requesting (requested=$requested tokenBucket=$tokenBucket)\")\n    }\n\n  def sendRequest(time: Long, items: Int): Unit = {\n    if (Debug) {\n      println(s\"$time: requesting $items items (requested=$requested tokenBucket=$tokenBucket)\")\n    }\n    workSource ! WorkRequest(self, items)\n    requested += items\n  }\n\n  request(lastTokenTime)\n\n  /**\n   * third part: using the above for rate-regulated message forwarding\n   */\n  def receive: Receive = {\n    case job: Job ⇒\n      val time = now()\n      if (Debug && requested == 1) {\n        println(s\"$time: received job\")\n      }\n      consumeToken(time)\n      requested -= 1\n      request(time)\n      calculator ! job\n  }\n}","title":"16.4 限流模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"前一章介绍了消息速率、负载和时间的各种概念；我们之前只考虑了不同组件之间和时间无关的关联。这一章增加了另一个正交维度来完成这整个版图：维持状态几乎是所有组件的共同目的，而我们还没有讨论应该怎么做到这一点。这里所呈现的模式彼此密切相关，并形成了一个有机整体。","title":"第17章——状态管理和持久化模式"},{"location":"/chapter-17/index.html#17-1-领域对象模式","text":"DomainObject.scala\nfinal case class ItemRef(id: URI)\n\nfinal case class CustomerRef(id: URI)\n\nfinal case class ShoppingCartRef(id: URI)\n清单 17-1 一个最小化的购物车定义\nfinal case class ShoppingCart(\n  items: Map[ItemRef, Int],\n  owner: Option[CustomerRef]) {\n  def setOwner(customer: CustomerRef): ShoppingCart = {\n    require(owner.isEmpty, \"owner cannot be overwritten\")\n    copy(owner = Some(customer))\n  }\n\n  def addItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(\n      count > 0,\n      s\"count must be positive (trying to add $item with count $count)\")\n    val currentCount = items.getOrElse(item, 0)\n    copy(items = items.updated(item, currentCount + count))\n  }\n\n  def removeItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(\n      count > 0,\n      s\"count must be positive (trying to remove $item with count $count)\")\n    val currentCount = items.getOrElse(item, 0)\n    val newCount = currentCount - count\n    if (newCount <= 0)\n      copy(items = items - item)\n    else\n      copy(items = items.updated(item, newCount))\n  }\n\n  // 代码清单 17-6\n  def applyEvent(event: Event): ShoppingCart = event match {\n    case OwnerChanged(_, owner)      ⇒ setOwner(owner)\n    case ItemAdded(_, item, count)   ⇒ addItem(item, count)\n    case ItemRemoved(_, item, count) ⇒ removeItem(item, count)\n  }\n\n  // 代码清单 17-6\n}\n\nobject ShoppingCart {\n  val empty = ShoppingCart(Map.empty, None)\n}\n清单 17-2 用于和购物车对象通信的消息\ntrait ShoppingCartMessage {\n  def shoppingCart: ShoppingCartRef\n}\n\nsealed trait Command extends ShoppingCartMessage\n\nfinal case class SetOwner(\n  shoppingCart: ShoppingCartRef,\n  owner:        CustomerRef) extends Command\n\nfinal case class AddItem(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Command\n\nfinal case class RemoveItem(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Command\n\nsealed trait Query extends ShoppingCartMessage\n\nfinal case class GetItems(shoppingCart: ShoppingCartRef) extends Query\n\nsealed trait Event extends ShoppingCartMessage\n\nfinal case class OwnerChanged(\n  shoppingCart: ShoppingCartRef,\n  owner:        CustomerRef) extends Event\n\nfinal case class ItemAdded(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Event\n\nfinal case class ItemRemoved(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Event\n\nsealed trait Result extends ShoppingCartMessage\n\nfinal case class GetItemsResult(\n  shoppingCart: ShoppingCartRef,\n  items:        Map[ItemRef, Int]) extends Result\n清单 17-3 一个购物车管理者 Actor\nfinal case class ManagerCommand(cmd: Command, id: Long, replyTo: ActorRef)\n\nfinal case class ManagerEvent(id: Long, event: Event)\n\nfinal case class ManagerQuery(cmd: Query, id: Long, replyTo: ActorRef)\n\nfinal case class ManagerResult(id: Long, result: Result)\n\nfinal case class ManagerRejection(id: Long, reason: String)\n\nclass Manager(var shoppingCart: ShoppingCart) extends Actor {\n  /*\n   * this is the usual constructor, the above allows priming with\n   * previously persisted state.\n   */\n  def this() = this(ShoppingCart.empty)\n\n  def receive: Receive = {\n    case ManagerCommand(cmd, id, replyTo) ⇒\n      try {\n        val event = cmd match {\n          case SetOwner(cart, owner) ⇒\n            shoppingCart = shoppingCart.setOwner(owner)\n            OwnerChanged(cart, owner)\n          case AddItem(cart, item, count) ⇒\n            shoppingCart = shoppingCart.addItem(item, count)\n            ItemAdded(cart, item, count)\n          case RemoveItem(cart, item, count) ⇒\n            shoppingCart = shoppingCart.removeItem(item, count)\n            ItemRemoved(cart, item, count)\n        }\n        replyTo ! ManagerEvent(id, event)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n    case ManagerQuery(cmd, id, replyTo) ⇒\n      try {\n        val result = cmd match {\n          case GetItems(cart) ⇒\n            GetItemsResult(cart, shoppingCart.items)\n        }\n        replyTo ! ManagerResult(id, result)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n  }\n}","title":"17.1 领域对象模式"},{"location":"/chapter-17/index.html#17-2-分片模式","text":"清单 17-4 为购物车定义分片算法\nobject ShardSupport {\n  /*\n   * use the shoppingCart reference as the sharding key; the partial function\n   * must return both the key and the message to be forwarded, and if it does\n   * not match then the message is dropped\n   */\n  val extractEntityId: ShardRegion.ExtractEntityId = {\n    case mc @ ManagerCommand(cmd, _, _) ⇒\n      cmd.shoppingCart.id.toString -> mc\n    case mc @ ManagerQuery(query, _, _) ⇒\n      query.shoppingCart.id.toString -> mc\n  }\n\n  /*\n   * allocate shoppingCarts into 256 shards based on the low 8 bits of their\n   * ID’s hash; this is a total function that must be defined for all messages\n   * that are forwarded\n   */\n  val extractShardId: ShardRegion.ExtractShardId = {\n    case ManagerCommand(cmd, _, _) ⇒\n      toHex(cmd.shoppingCart.id.hashCode & 255)\n    case ManagerQuery(query, _, _) ⇒\n      toHex(query.shoppingCart.id.hashCode & 255)\n  }\n\n  private def toHex(b: Int) =\n    new java.lang.StringBuilder(2)\n      .append(hexDigits(b >> 4))\n      .append(hexDigits(b & 15))\n      .toString\n\n  private val hexDigits = \"0123456789ABCDEF\"\n\n  val RegionName = \"ShoppingCart\"\n}\n清单 17-5 启动一个群集来托管分片\nval sys1 = ActorSystem(\"ShardingExample\", node1Config.withFallback(clusterConfig))\nval seed = Cluster(sys1).selfAddress\n\ndef startNode(sys: ActorSystem): Unit = {\n  Cluster(sys).join(seed)\n  ClusterSharding(sys).start(\n    typeName = ShardSupport.RegionName,\n    entityProps = Props(new Manager),\n    settings = ClusterShardingSettings(sys1),\n    extractEntityId = ShardSupport.extractEntityId,\n    extractShardId = ShardSupport.extractShardId)\n}\n\nstartNode(sys1)\n\nval sys2 = ActorSystem(\"ShardingExample\", clusterConfig)\nstartNode(sys2)\nSharding.scala\nval manager = ClusterSharding(sys1).shardRegion(ShardSupport.RegionName)","title":"17.2 分片模式"},{"location":"/chapter-17/index.html#17-3-事件溯源模式","text":"清单 17-6 将领域事件添加到业务逻辑\nfinal case class ShoppingCart(\n  items: Map[ItemRef, Int],\n  owner: Option[CustomerRef]) {\n  def setOwner(customer: CustomerRef): ShoppingCart = {\n    require(owner.isEmpty, \"owner cannot be overwritten\")\n    copy(owner = Some(customer))\n  }\n\n  def addItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(\n      count > 0,\n      s\"count must be positive (trying to add $item with count $count)\")\n    val currentCount = items.getOrElse(item, 0)\n    copy(items = items.updated(item, currentCount + count))\n  }\n\n  def removeItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(\n      count > 0,\n      s\"count must be positive (trying to remove $item with count $count)\")\n    val currentCount = items.getOrElse(item, 0)\n    val newCount = currentCount - count\n    if (newCount <= 0)\n      copy(items = items - item)\n    else\n      copy(items = items.updated(item, newCount))\n  }\n\n  // 代码清单 17-6\n  def applyEvent(event: Event): ShoppingCart = event match {\n    case OwnerChanged(_, owner)      ⇒ setOwner(owner)\n    case ItemAdded(_, item, count)   ⇒ addItem(item, count)\n    case ItemRemoved(_, item, count) ⇒ removeItem(item, count)\n  }\n\n  // 代码清单 17-6\n}\n\nobject ShoppingCart {\n  val empty = ShoppingCart(Map.empty, None)\n}\n清单 17-7 持久化一个事件溯源领域对象\nclass PersistentObjectManager extends PersistentActor {\n  // we expect the name to be the shopping card ID\n  override def persistenceId: String = context.self.path.name\n\n  private var shoppingCart: ShoppingCart = ShoppingCart.empty\n\n  def receiveCommand: Receive = {\n    case ManagerCommand(cmd, id, replyTo) ⇒\n      try {\n        val event = cmd match {\n          case SetOwner(cart, owner)         ⇒ OwnerChanged(cart, owner)\n          case AddItem(cart, item, count)    ⇒ ItemAdded(cart, item, count)\n          case RemoveItem(cart, item, count) ⇒ ItemRemoved(cart, item, count)\n        }\n        // perform the update here in order to treat validation errors immediately\n        shoppingCart = shoppingCart.applyEvent(event)\n        persist(event) { _ ⇒\n          replyTo ! ManagerEvent(id, event)\n        }\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n    case ManagerQuery(cmd, id, replyTo) ⇒\n      try {\n        val result = cmd match {\n          case GetItems(cart) ⇒ GetItemsResult(cart, shoppingCart.items)\n        }\n        replyTo ! ManagerResult(id, result)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n  }\n\n  def receiveRecover: Receive = {\n    case e: Event ⇒ shoppingCart = shoppingCart.applyEvent(e)\n  }\n}","title":"17.3 事件溯源模式"},{"location":"/chapter-17/index.html#17-4-事件流模式","text":"清单 17-8 在写日志期间对事件打标签\nclass ShoppingCartTagging(system: ExtendedActorSystem)\n  extends WriteEventAdapter {\n  def manifest(event: Any): String = \"\" // no additional manifest needed\n\n  def toJournal(event: Any): Any =\n    event match {\n      case s: ShoppingCartMessage ⇒ Tagged(event, Set(\"shoppingCart\"))\n      case other                  ⇒ other\n    }\n}\n清单 17-9 一个正在监听事件流的 Actor\nobject TopProductListener {\n\n  private class IntHolder(var value: Int)\n\n}\n\nclass TopProductListener extends Actor with ActorLogging {\n\n  import TopProductListener._\n\n  private implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n  private val readJournal: LeveldbReadJournal =\n    PersistenceQuery(context.system)\n      .readJournalFor[LeveldbReadJournal](LeveldbReadJournal.Identifier)\n\n  readJournal.eventsByTag(tag = \"shoppingCart\", offset = Sequence(0L))\n    .collect { case EventEnvelope(_, _, _, add: ItemAdded) ⇒ add }\n    .groupedWithin(100000, 1.second)\n    .addAttributes(Attributes.asyncBoundary)\n    .runForeach { seq: Seq[ItemAdded] ⇒\n      val histogram = seq.foldLeft(Map.empty[ItemRef, IntHolder]) {\n        (map, event) ⇒\n          map.get(event.item) match {\n            case Some(holder) ⇒\n              holder.value += event.count\n              map\n            case None ⇒\n              map.updated(event.item, new IntHolder(event.count))\n          }\n      }\n      self ! TopProducts(0, histogram.map(p ⇒ (p._1, p._2.value)))\n    }\n\n  private var topProducts = Map.empty[ItemRef, Int]\n\n  def receive: Receive = {\n    case GetTopProducts(id, replyTo) ⇒\n      replyTo ! TopProducts(id, topProducts)\n    case TopProducts(_, products) ⇒\n      topProducts = products\n      log.info(\"new {}\", products)\n  }\n}","title":"17.4 事件流模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"},{"location":"/extras.html","text":"","title":"额外指引 ·"},{"location":"/extras.html#额外指引","text":"Netty In Action In Scala","title":"额外指引"},{"location":"/errata.html","text":"","title":"勘误 ·"},{"location":"/errata.html#勘误","text":"本书的勘误将第一时间在这个页面进行同步。并按照章节和页码的升序进行排列。本书原著的勘误也会进行第一时间的合并， 在本书中文版出版时，我们已经合并了原著到2018年三月份的勘误。外版勘误地址\n勘误的模板为\n### 章节\n\n#### 版次\n\n#### 页码\n\n#### 原文\n\n#### 修正\n\n#### 说明\n\n--- 分隔符","title":"勘误"},{"location":"/errata.html#全书代码清单更新","text":"","title":"全书代码清单更新"},{"location":"/errata.html#版次","text":"第一次印刷","title":"版次"},{"location":"/errata.html#页码","text":"所有涉及到case class的代码清单","title":"页码"},{"location":"/errata.html#原文","text":"case class","title":"原文"},{"location":"/errata.html#修正","text":"final case class","title":"修正"},{"location":"/errata.html#说明","text":"case class 如果不带 final 标识符，在 Java 中依然是可以继承的，造成非常不好的体验。通常来说，对于需要和 Java 进行交互的库来说，在编写时 case class 需要定义为 final case class 从而限定他们在 Java 中的可继承性。而对于 case object来说，因为天然等于加了final，所以不需要了。\n—-","title":"说明"},{"location":"/errata.html#译者序1","text":"","title":"译者序1"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"VI","title":"页码"},{"location":"/errata.html#原文","text":"欧宁猫","title":"原文"},{"location":"/errata.html#修正","text":"欧林猫","title":"修正"},{"location":"/errata.html#说明","text":"弄错了 OlingCat大小姐的中文网名\n—-","title":"说明"},{"location":"/errata.html#第一章","text":"","title":"第一章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"9","title":"页码"},{"location":"/errata.html#原文","text":"而且不如就近保存有答案可靠","title":"原文"},{"location":"/errata.html#修正","text":"而且不如在就近就保存有答案可靠","title":"修正"},{"location":"/errata.html#说明","text":"这里微调语序，添加译者注：\n这里的含义有多重，比如应用相应的缓存，以及就近建设数据中心，一般来说，大型的互联网服务提供商一般都会选择多地多中心的方式来架设并提供他们的服务。","title":"说明"},{"location":"/errata.html#第二章","text":"","title":"第二章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"15","title":"页码"},{"location":"/errata.html#原文","text":"public Images cache;\n  public Images database;","title":"原文"},{"location":"/errata.html#修正","text":"private Images cache;\n  private Images database;","title":"修正"},{"location":"/errata.html#说明","text":"这里暴露了ImageServiceController的内部成员，需要将可见性设置为private.","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"19","title":"页码"},{"location":"/errata.html#原文","text":"ReplyA a = computeA();\n    ReplyB b = computeB();\n    ReplyC c = computeC();\n\n    Result r = aggregate(a, b, c);","title":"原文"},{"location":"/errata.html#修正","text":"final ReplyA a = computeA();\n    final ReplyB b = computeB();\n    final ReplyC c = computeC();\n\n    final Result r = aggregate(a, b, c);","title":"修正"},{"location":"/errata.html#说明","text":"在反应式编程中，我们应该尽可能地利用不可变，类似于在 Scala 中，我们需要尽可能地使用 val 而不是 var,并且保持和 2.2.2 小节的 Scala 代码清单对齐（其中使用的是val）。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"20","title":"页码"},{"location":"/errata.html#原文","text":"Future<ReplyA> a = taskA();\n    Future<ReplyB> b = taskB();\n    Future<ReplyC> c = taskC();\n\n    Result r = aggregate(a.get(), b.get(), c.get());","title":"原文"},{"location":"/errata.html#修正","text":"final Future<ReplyA> a = taskA();\n    final Future<ReplyB> b = taskB();\n    final Future<ReplyC> c = taskC();\n\n    final Result r = aggregate(a.get(), b.get(), c.get());","title":"修正"},{"location":"/errata.html#说明","text":"在反应式编程中，我们应该尽可能地利用不可变，类似于在 Scala 中，我们需要尽可能地使用 val 而不是 var,并且保持和 2.2.2 小节的 Scala 代码清单对齐（其中使用的是val）。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"23","title":"页码"},{"location":"/errata.html#原文","text":"为了充分利用….，也要运行成百上千的线程。","title":"原文"},{"location":"/errata.html#修正","text":"为了充分利用（榨干）CPU可被利用到的性能，意味着，我们就算在最普通的硬件上也要运行成百上千的线程。 //TODO 继续微调","title":"修正"},{"location":"/errata.html#说明","text":"这里的断句原来有点问题。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"23","title":"页码"},{"location":"/errata.html#原文","text":"CompletionStage<Response> future =\n        ask(actorRef, request, timeout).thenApply(Response.class::cast);\n    future.thenAccept(AskActorWithJava8::processIt);","title":"原文"},{"location":"/errata.html#修正","text":"final CompletionStage<Response> future =\n        ask(actorRef, request, timeout).thenApply(Response.class::cast);\n    future.thenAccept(AskActorWithJava8::processIt);","title":"修正"},{"location":"/errata.html#说明","text":"在反应式编程中，我们应该尽可能地利用不可变，类似于在 Scala 中，我们需要尽可能地使用 val 而不是 var。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"27","title":"页码"},{"location":"/errata.html#原文","text":"成为昂贵的门挡。","title":"原文"},{"location":"/errata.html#修正","text":"这里需要添加一个译者注： 这里的门挡即门碰，作者这里指的是硬盘坏了，废物利用用来挡门。可以理解为使用不再感兴趣的书本来垫显示器。","title":"修正"},{"location":"/errata.html#说明","text":"在反应式编程中，我们应该尽可能地利用不可变，类似于在 Scala 中，我们需要尽可能地使用 val 而不是 var。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"32","title":"页码"},{"location":"/errata.html#原文","text":"传统的数据存储是关系型数据库，它提供了非常高水平的一致性保证。数据库供应商的客户已习惯于这种操作模式——不仅是因为要提升数据库的效率，而且还要保证提供ACID事务语义的需求；已经为此付出大量努力，做了深入研究。为此，分布式系统目前都聚焦在提供了强一致性的关键组件上。","title":"原文"},{"location":"/errata.html#修正","text":"传统的数据存储是有着非常高水平的强一致性保证的关系型数据库。数据库厂商们在过去投入了大量努力和研究来提升产品效率，与此同时，也坚持着保证ACID的事务性语义，而他们的客户也习惯了这种产品运营模式。为此，目前不少分布式系统也集中精力在其关键组件上提供某种程度的强一致性。","title":"修正"},{"location":"/errata.html#说明","text":"这里原文的倒装比较严重，中间夹了一句，我们重新调整下翻译的结构使得原文的表意更加突出。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"33","title":"页码"},{"location":"/errata.html#原文","text":"那么这两个事件的观察顺序…","title":"原文"},{"location":"/errata.html#修正","text":"那么这两个事件受观察的顺序…","title":"修正"},{"location":"/errata.html#说明","text":"这里讲的是狭义相对论。","title":"说明"},{"location":"/errata.html#第三章","text":"","title":"第三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"48","title":"页码"},{"location":"/errata.html#原文","text":"STM","title":"原文"},{"location":"/errata.html#修正","text":"应该是：STW","title":"修正"},{"location":"/errata.html#说明","text":"翻译的时候想着软件事务内存了，Typo。","title":"说明"},{"location":"/errata.html#第三章","text":"","title":"第三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"48","title":"页码"},{"location":"/errata.html#原文","text":"吞吐量从而提升为将近原来的3倍","title":"原文"},{"location":"/errata.html#修正","text":"从而将吞吐量提升为将近原来的3倍","title":"修正"},{"location":"/errata.html#说明","text":"语序调整","title":"说明"},{"location":"/errata.html#第三章","text":"","title":"第三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"49","title":"页码"},{"location":"/errata.html#原文","text":"我们都将会评估它是如何…的。","title":"原文"},{"location":"/errata.html#修正","text":"删除掉最后的的字。\n我们都将会评估它是….的原则。","title":"修正"},{"location":"/errata.html#说明","text":"","title":"说明"},{"location":"/errata.html#第三章","text":"","title":"第三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"49","title":"页码"},{"location":"/errata.html#原文","text":"所以它们的在容错性方面比较欠缺。","title":"原文"},{"location":"/errata.html#修正","text":"删除掉中间的的字。\n所以它们在容错性方面比较欠缺。","title":"修正"},{"location":"/errata.html#说明","text":"","title":"说明"},{"location":"/errata.html#第三章","text":"","title":"第三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"53","title":"页码"},{"location":"/errata.html#原文","text":"译者注 26 ：Java 8 并未内置… ,参见 vavr.io …","title":"原文"},{"location":"/errata.html#修正","text":"Java 8 并未内置类名类似于“Promise”的实现，不过在 Netty 等流行的异步网络编程库中都有名为“Promise”的定义和实现。—— 译者注","title":"修正"},{"location":"/errata.html#说明","text":"在本书出版的时候，译者使用的是 vavr 的0.9.2版本,在这个版本中的确有 Promise 的定义和对应的实现，见： io.vavr.concurrent.Promise，不过在目前的主干和接下来的1.0.0版本中，vavr的作者已经删除对应的实现， 所以这里的描述已经过时。\n—","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"55","title":"页码"},{"location":"/errata.html#原文","text":"代码清单3-5 supplyAsync后面少了括号","title":"原文"},{"location":"/errata.html#修正","text":"public class ParallelRetrievalExample {\n  private final CacheRetriever cacheRetriever;\n  private final DBRetriever dbRetriever;\n\n  ParallelRetrievalExample(CacheRetriever cacheRetriever, DBRetriever dbRetriever) {\n    this.cacheRetriever = cacheRetriever;\n    this.dbRetriever = dbRetriever;\n  }\n\n  public Object retrieveCustomer(final long id) {\n    final CompletableFuture<Object> cacheFuture =\n        CompletableFuture.supplyAsync(() -> cacheRetriever.getCustomer(id));\n    final CompletableFuture<Object> dbFuture =\n        CompletableFuture.supplyAsync(() -> dbRetriever.getCustomer(id));\n\n    return CompletableFuture.anyOf(cacheFuture, dbFuture);\n  }\n}","title":"修正"},{"location":"/errata.html#说明","text":"排版过程中引入错误，typo。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"58","title":"页码"},{"location":"/errata.html#原文","text":"译者注 37：在 RXJava 2.x 的版本中….","title":"原文"},{"location":"/errata.html#修正","text":"在 RxJava 2.x 的版本中….","title":"修正"},{"location":"/errata.html#说明","text":"这里的RxJava 的第二个 x 需要小写，属于 typo。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"59","title":"页码"},{"location":"/errata.html#原文","text":"private static final RxJavaExample rxJavaExample = new RxJavaExample();\n和\nrxJavaExample.observe(strings);","title":"原文"},{"location":"/errata.html#修正","text":"private static final RxJavaExample RX_JAVA_EXAMPLE = new RxJavaExample();\n和\nRX_JAVA_EXAMPLE.observe(strings);","title":"修正"},{"location":"/errata.html#说明","text":"静态的成员变量，应该推荐使用大写加下划线的形式。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"59","title":"页码"},{"location":"/errata.html#原文","text":"代码清单中 Observable.fromArray(strings).subscribe(s) 少了括号","title":"原文"},{"location":"/errata.html#修正","text":"package chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n  public void observe(String[] strings) {\n    Observable.fromArray(strings).subscribe((s) -> System.out.println(\"Received \" + s));\n  }\n}","title":"修正"},{"location":"/errata.html#说明","text":"排版过程中引入错误，typo。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"60","title":"页码"},{"location":"/errata.html#原文","text":"Erlang的开放电信平台……定义了对于Acotr的…","title":"原文"},{"location":"/errata.html#修正","text":"Acotr 改为 Actor.","title":"修正"},{"location":"/errata.html#说明","text":"排版过程中引入错误，typo。","title":"说明"},{"location":"/errata.html#第四章","text":"","title":"第四章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"77","title":"页码"},{"location":"/errata.html#原文","text":"Actor模型的实现通常提供…..“至多一次保证”，","title":"原文"},{"location":"/errata.html#修正","text":"Actor模型的实现通常提供…..“至多一次送达”，","title":"修正"},{"location":"/errata.html#说明","text":"保证应该改为送达","title":"说明"},{"location":"/errata.html#第十一章","text":"","title":"第十一章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"143","title":"页码"},{"location":"/errata.html#原文","text":"val echo = echoService(\"keepSLAfuture\")","title":"原文"},{"location":"/errata.html#修正","text":"val echo = echoService(\"keepSLAWithFuture\")","title":"修正"},{"location":"/errata.html#说明","text":"typo","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"144","title":"页码"},{"location":"/errata.html#原文","text":"val echo = echoService(\"keepSLAparallel\")\n和\nval controller = system.actorOf(\n        Props[ParallelSLATester],\n        \"keepSLAparallelController\")","title":"原文"},{"location":"/errata.html#修正","text":"val echo = echoService(\"keepSLAInParallel\")\n和\nval controller = system.actorOf(\n        Props[ParallelSLATester],\n        \"keepSLAInParallelController\")","title":"修正"},{"location":"/errata.html#说明","text":"typo","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"147","title":"页码"},{"location":"/errata.html#原文","text":"例如：在Akka中给一个Actor发消息：actor!message。","title":"原文"},{"location":"/errata.html#修正","text":"例如：在Akka中给一个Actor发消息：actor ! message。","title":"修正"},{"location":"/errata.html#说明","text":"注13最后一句（页面底部）。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"149","title":"页码"},{"location":"/errata.html#原文","text":"val controller = system.actorOf(\n        Props[ParallelSLATester],\n        \"keepSLAparallelController\")","title":"原文"},{"location":"/errata.html#修正","text":"val controller = system.actorOf(\n        Props[ParallelSLATester],\n        \"keepSLAInParallelAndAsyncController\")","title":"修正"},{"location":"/errata.html#说明","text":"typo 因为在 ParallelSLATester 中，对应的context.stop(self)是一个异步动作，所以在快速运行多个测试的时候， 会出现偶发的：akka.actor.InvalidActorNameException，所以进行改名对当前的用例来说是比较直接安全的一种做法。 感兴趣的读者可以看下下面的错误信息：\n[info] - must keep its SLA when used in parallel and handling responses asynchronously *** FAILED ***\n[info]   akka.actor.InvalidActorNameException: actor name [keepSLAparallelController] is not unique!\n[info]   at akka.actor.dungeon.ChildrenContainer$NormalChildrenContainer.reserve(ChildrenContainer.scala:129)\n[info]   at akka.actor.dungeon.Children.reserveChild(Children.scala:134)\n[info]   at akka.actor.dungeon.Children.reserveChild$(Children.scala:132)\n[info]   at akka.actor.ActorCell.reserveChild(ActorCell.scala:431)\n[info]   at akka.actor.dungeon.Children.makeChild(Children.scala:272)\n[info]   at akka.actor.dungeon.Children.attachChild(Children.scala:48)\n[info]   at akka.actor.dungeon.Children.attachChild$(Children.scala:47)\n[info]   at akka.actor.ActorCell.attachChild(ActorCell.scala:431)\n[info]   at akka.actor.ActorSystemImpl.actorOf(ActorSystem.scala:753)\n[info]   at chapter11.EchoServiceSpec.$anonfun$new$10(EchoServiceSpec.scala:242)\n原始链接","title":"说明"},{"location":"/errata.html#第十三章","text":"","title":"第十三章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"220","title":"页码"},{"location":"/errata.html#原文","text":"代码清单 13-15：\ncase SeqResult(_, res, replica, _) if res != right ⇒ replica","title":"原文"},{"location":"/errata.html#修正","text":"case SeqResult(_, result, replica, _) if res != right ⇒ replica","title":"修正"},{"location":"/errata.html#说明","text":"代码清单中的这个部分，因为res shallow 了外面的 add方法中的res参数，所以 实际上比较的类型是不相关的，会造成状态无法收敛到Known。通过重新命名解决了这个问题。","title":"说明"},{"location":"/errata.html#第十四章","text":"","title":"第十四章"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"231","title":"页码"},{"location":"/errata.html#原文","text":"代码清单 14-1：\nAmazonEC2 amazonEC2Client = new AmazonEC2Client(credentials);","title":"原文"},{"location":"/errata.html#修正","text":"final AmazonEC2 amazonEC2Client =\n        AmazonEC2ClientBuilder.standard()\n            .withCredentials(new AWSStaticCredentialsProvider(credentials))\n            .build();","title":"修正"},{"location":"/errata.html#说明","text":"切换到新版本客户端的推荐写法，旧版本写法已经废弃。其他包括代码清单中添加了final关键字。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"235","title":"页码"},{"location":"/errata.html#原文","text":"代码清单 14-5：\npublic WorkerNode(final InetAddress address, final FiniteDuration checkInterval) {\n      checkTimer =\n          getContext()\n              .system()\n              .scheduler()\n              .schedule(\n                  checkInterval,\n                  checkInterval,\n                  self(),\n                  DoHealthCheck.instance,\n                  getContext().dispatcher(),\n                  self());\n    }","title":"原文"},{"location":"/errata.html#修正","text":"public WorkerNode(final InetAddress address, final Duration checkInterval) {\n      checkTimer =\n          getContext()\n              .getSystem()\n              .getScheduler()\n              .schedule(\n                  checkInterval,\n                  checkInterval,\n                  self(),\n                  DoHealthCheck.INSTANCE,\n                  getContext().dispatcher(),\n                  self());\n    }","title":"修正"},{"location":"/errata.html#说明","text":"切换到新版本 Akka 中更加 Java native 的写法。并且针对静态类成员 DoHealthCheck.instance 应用大写格式。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"235","title":"页码"},{"location":"/errata.html#原文","text":"代码清单 14-5：\nprivate PartialFunction<Object, BoxedUnit> initialized()","title":"原文"},{"location":"/errata.html#修正","text":"private Receive initialized()","title":"修正"},{"location":"/errata.html#说明","text":"切换到新版本 Akka 中更加 Java native 的写法。更加直接地是用 AbstractActor 提供的基础设施。\n240","title":"说明"},{"location":"/errata.html#原文","text":"代码清单 14-5：\nprivate PartialFunction<Object, BoxedUnit> initialized()","title":"原文"},{"location":"/errata.html#修正","text":"private Receive initialized()","title":"修正"},{"location":"/errata.html#说明","text":"切换到新版本 Akka 中更加 Java native 的写法。更加直接地是用 AbstractActor 提供的基础设施。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"247","title":"页码"},{"location":"/errata.html#原文","text":"代码清单 14-8：\nprivate static final ScriptEngine engine =","title":"原文"},{"location":"/errata.html#修正","text":"private static final ScriptEngine ENGINE =","title":"修正"},{"location":"/errata.html#说明","text":"对于类的静态成员，切换为使用全大写的格式。其他包含一些final关键字的增加。","title":"说明"},{"location":"/errata.html#第一次印刷","text":"","title":"第一次印刷"},{"location":"/errata.html#页码","text":"108","title":"页码"},{"location":"/errata.html#原文","text":"脚注 3：在领域驱动设计的上下文中，这些将称为聚合根源；…","title":"原文"},{"location":"/errata.html#修正","text":"脚注 3：在领域驱动设计的上下文中，这些被称为聚合根；…","title":"修正"},{"location":"/errata.html#说明","text":"原文是：In the context of domain-driven design, these would be called aggregate roots;\naggregate roots 应该译为「聚合根」，而不是「聚合根源」。另外，这里没也必要使用将来时，直接译作「被称为」即可。","title":"说明"}]}