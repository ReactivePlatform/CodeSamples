{"docs":[{"location":"/index.html","text":"目录 内容提要 第一部分 简介 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业工具 第二部分 微言大义 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——有规划的失败处理 第8章——有界一致性 第9章——按需使用非确定性 第10章——消息流 第三部分 设计模式 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言 额外指引 勘误\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）系统设计的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/abstract.html","text":"","title":"内容提要 ·"},{"location":"/abstract.html#内容提要","text":"TODO","title":"内容提要"},{"location":"/part1.html","text":"","title":"第一部分 简介 ·"},{"location":"/part1.html#第一部分-简介","text":"你有曾思考过高性能Web应用程序是如何实现的吗？社交网络和大型零售网站肯定有一些秘密配方使得系统运行迅速并且可靠，但这些秘密是什么呢？在这本书中，我们将为你揭晓谜底，你将学习到这些近似永远不出故障，并且能够满足数十亿人需要的系统背后的设计原则与模式。虽然你所构建的系统未必有如此雄心壮志的要求，但是它们主要的特质应该是一致的：\n你想要你的应用程序可靠地工作，即使某些部件（硬件或者软件）有可能出现故障。\n你希望你的应用程序在你需要支撑更多的用户时，可以持续地提供服务，而且你希望能够通过添加或者删除资源来调整它的能力，从而适应不断变化的需求（没有可以预测未来的水晶球的帮助，很难进行正确的容量规划）。\n在第1章中，我们将勾勒出一个具备这些特质的应用程序的开发过程。我们将指明你会遇到的挑战，并基于一个具体的例子（一个假想中的Gmail服务实现）给出解决方案，但是我们将会以不提供具体的技术选型的形式进行。\n这个使用场景为接下来在第2章中对《反应式宣言》所进行的详细讨论作了铺垫。该宣言以简洁、抽象的形式撰写，目的是为了聚焦于它的本质：将多个独立的、有效的程序特性凝聚为一个整体，从而形成更大的合力。我们将通过把高度抽象的特质分解为更小的部分，并解释各部分又是如何合回一体的过程，来展现这一点。\n我们将会以第3章结束这一部分，其大致地介绍了行业工具：函数式编程、Future 和 Promise、通信顺序进程（CSP）、 Observer 和 Observable（Reactive Extensions）以及 Actor 模型。","title":"第一部分 简介"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"我们的初心，是构建一个对用户即时响应的（responsive）系统。这意味着该系统无论在什么样的情况下，都应该能即时响应用户的输入。由于任何单台计算机在任何时刻都有可能宕机，所以我们需要将这一个系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。在过去，我们建立了各种方法来允许我们维持某种假像：单线程的本地运算能够魔法般地扩展运行在多个处理器核心或者网络节点上。然而，这虚实之间的沟壑已经大到难以为继。而解决之法是让我们的应用程序中所具有的分布和并发的本质明明白白地反映到编程模型上来，并使它变成我们的优势。\n没有代码清单","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"这一章详细地介绍了《反应式宣言》：原文文字简练且内容紧凑，我们将在这里加以展开并进行深入地讨论。有关该宣言相关理论的更多背景知识，请参阅本书第二部分。","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#2-1-对用户作出反应","text":"代码清单 2-1 图片服务中简单 Controller 的一段代码\npublic interface Images {\n  Image get(String Key);\n\n  void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key) {\n  Image result = cache.get(key);\n  if (result != null) {\n    return result;\n  } else {\n    result = database.get(key);\n    if (result != null) {\n      cache.add(key, result);\n      return result;\n    } else {\n      return fallback;\n    }\n  }\n}","title":"2.1 对用户作出反应"},{"location":"/chapter-02/index.html#2-2-利用并行性","text":"SimpleFunction.scala\nval result = f(42)\nSequentialExecution.java\nReplyA a = computeA();\nReplyB b = computeB();\nReplyC c = computeC();\n\nResult r = aggregate(a, b, c);\nParallelExecutionWithJavaFuture.java\nFuture<ReplyA> a = taskA();\nFuture<ReplyB> b = taskB();\nFuture<ReplyC> c = taskC();\n\nResult r = aggregate(a.get(), b.get(), c.get());\nParallelExecutionWithScalaFuture.scala\nval fa: Future[ReplyA] = taskA()\nval fb: Future[ReplyB] = taskB()\nval fc: Future[ReplyC] = taskC()\n\nval fr: Future[Result] = for (a ← fa; b ← fb; c ← fc)\n  yield aggregate(a, b, c)\nBlockingSocketRead.java\nfinal Socket socket = new Socket(\"127.0.0.1\", 8080);\nsocket.getOutputStream().write(requestMessageBytes);\nfinal int bytesRead = socket.getInputStream().read(responseBuffer);\nAskActorWithJava8.java\nCompletionStage<Response> future =\n  ask(actorRef, request, timeout)\n    .thenApply(Response.class::cast);\nfuture.thenAccept(response -> AskActorWithJava8.processIt(response));","title":"2.2 利用并行性"},{"location":"/chapter-02/index.html#2-4-对失败作出反应","text":"ExceptionHandler.scala\ntry {\n  f(i)\n} catch {\n  case _: java.lang.ArithmeticException ⇒ Int.MaxValue\n  case ex: java.lang.StackOverflowError ⇒ ???\n  case ex: java.net.ConnectException    ⇒ ???\n}","title":"2.4 对失败作出反应"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业工具 ·"},{"location":"/chapter-03/index.html#第3章-行业工具","text":"","title":"第3章——行业工具"},{"location":"/chapter-03/index.html#3-2-函数式编程","text":"代码清单3-1 不安全的、可变的消息类，可能会隐含非预期的行为\nimport java.util.Date;\n\npublic class Unsafe {\n  private Date timestamp;\n  private final StringBuffer message;\n\n  public Unsafe(Date timestamp, StringBuffer message) {\n    this.timestamp = timestamp;\n    this.message = message;\n  }\n\n  public synchronized Date getTimestamp() {\n    return timestamp;\n  }\n\n  public synchronized void setTimestamp(Date timestamp) {\n    this.timestamp = timestamp;\n  }\n\n  public StringBuffer getMessage() {\n    return message;\n  }\n}\n代码清单 3-2 不可变的消息类，其行为是可预知的，并易于推断\nimport java.util.Date;\n\npublic class Immutable {\n  private final Date timestamp;\n  private final String message;\n\n  public Immutable(final Date timestamp, final String message) {\n    this.timestamp = new Date(timestamp.getTime());\n    this.message = message;\n  }\n\n  public Date getTimestamp() {\n    return new Date(timestamp.getTime());\n  }\n\n  public String getMessage() {\n    return message;\n  }\n}\nMessage.scala\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)\nUsingStringBuffer.java\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n    \"original '%s', new value '%s'\",\n    original,\n    reversed));\n代码清单 3-3 引用透明性：允许代换预先计算好的值\npublic class Rooter {\n  private final double value;\n  private Double root = null;\n\n  public Rooter(double value) {\n    this.value = value;\n  }\n\n  public double getValue() {\n    return value;\n  }\n\n  public double getRoot() {\n    if (root == null) {\n      root = Math.sqrt(value);\n    }\n    return root;\n  }\n}\n代码清单3-4 因副作用而受限的可用性\npublic class SideEffecting implements Serializable, Cloneable {\n  private int count;\n\n  public SideEffecting(int start) {\n    this.count = start;\n  }\n\n  public int next() {\n    this.count += Math.incrementExact(this.count);\n    return this.count;\n  }\n}\nIntSeeding.java\nfinal int next = se.next();\nif (logger.isDebugEnabled()) {\n  logger.debug(\"Next is \" + se.next());\n}\nreturn next;\nUsingMapFunction.java\nfinal List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n  numbers.stream()\n    .map(number -> number + 1)\n    .collect(Collectors.toList());\nPython REPL\n>>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"3.2 函数式编程"},{"location":"/chapter-03/index.html#3-4-对反应式设计的现有支持","text":"sample.js\nvar http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n    counter++;\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');\nsample.go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\titerations := 10\n\tmyChannel := make(chan int)\n\n\tgo producer(myChannel, iterations)\n\tgo consumer(myChannel, iterations)\n\n\ttime.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n\tfor i := 1; i <= iterations; i++ {\n\t\tfmt.Println(\"Sending: \", i)\n\t\tmyChannel <- i\n\t}\n}\n\nfunc consumer(myChannel chan int, iterations int) {\n\tfor i := 1; i <= iterations; i++ {\n\t\trecVal := <-myChannel\n\t\tfmt.Println(\"Received: \", recVal)\n\t}\n}\n代码清单3-5 从更快的数据源获取结果\npublic class ParallelRetrievalExample {\n  private final CacheRetriever cacheRetriever;\n  private final DBRetriever dbRetriever;\n\n  ParallelRetrievalExample(CacheRetriever cacheRetriever,\n      DBRetriever dbRetriever) {\n    this.cacheRetriever = cacheRetriever;\n    this.dbRetriever = dbRetriever;\n  }\n\n  public Object retrieveCustomer(final long id) {\n    final CompletableFuture<Object> cacheFuture = CompletableFuture\n      .supplyAsync(() -> cacheRetriever.getCustomer(id));\n    final CompletableFuture<Object> dbFuture = CompletableFuture\n      .supplyAsync(() -> dbRetriever.getCustomer(id));\n\n    return CompletableFuture.anyOf(cacheFuture, dbFuture);\n  }\n}\n代码清单3-6 使用Scala编程语言将两个Future的结果组合为单一结果\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutor(ForkJoinPool.commonPool())\n\ndef getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n  // Import the duration DSL to be used in the timeout\n  import scala.concurrent.duration._\n\n  // Provide the thread pool and Future timeout value to be applied\n  implicit val timeout: FiniteDuration = 250 milliseconds\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}\nStagedFuturesAsyncExample.scala\nimport scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}\nRxJavaExample.java\npackage chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n  public void observe(String[] strings) {\n    Observable.fromArray(strings).subscribe((s) -> {\n      System.out.println(\"Received \" + s);\n    });\n  }\n}\nRxJavaExampleDriver.java\npackage chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n  private static final RxJavaExample rxJavaExample = new RxJavaExample();\n\n  public static void main(String[] args) {\n    String[] strings = {\"a\", \"b\", \"c\"};\n    rxJavaExample.observe(strings);\n  }\n}\n代码清单3-7 一个使用 Akka 的Actor的例子\npackage chapter03.actor\n\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.actor._\nimport akka.event.LoggingReceive\n\ncase object Start\n\ncase class CounterMessage(counterValue: Int)\n\ncase class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"3.4 对反应式设计的现有支持"},{"location":"/part2.html","text":"","title":"第二部分 微言大义 ·"},{"location":"/part2.html#第二部分-微言大义","text":"这本书的第一部分综述了反应式系统的价值。你看到了对用户输入总是保持回弹性和可伸缩性的需要，从而即使在失败和不同负载的情况下也能保持即时响应性。在我们探索这些可取的属性过程中，你得出了需要使用消息驱动来作为底层实现的必要性。\n第二部分对反应式的 4 个特质进行了补充说明：提出了一组构建反应式架构的构建块。这一部分的重点是如何做到反应式，而第一部分则描述了我们要实现的目标及缘由。在这一部分所讨论的指导原则，以及我们在第3章中所介绍的行业工具，一起构成了第三部分中多种模式的基础。\n我们决定以一种连贯、凝聚的方式组织这些材料，以便你在构建反应式应用程序的过程中，推敲你自己的模式设计时，本书可以方便地作为一个紧凑的参考。作为一个完整的反应式架构的360度全景，这一部分涵盖了大量的基础理论。你可能想要先阅读第4章，然后略读这一部分的其余章节，并在你研究这本书第三部分中所介绍的相应模式时，再回过头来细细研读这部分中的对应章节。\n在这一部分中，你将学习到：\n通过显式的异步消息传递来使得封装和隔离成为可能； 通过位置透明性，提高组合能力，并添加水平扩展能力； 应用分而治之（divide et regna），以层级化模块的形式组织系统； 这个层级结构如何使得原则化的失败处理成为可能； 在分布式系统中实现足够一致的程序语义； 尽可能地避免不确定性，并在必要时添加； 使用基于消息流的拓扑指导反应式应用程序设计。","title":"第二部分 微言大义"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"事件，是建立消息传递的基石：事实上，一个特定条件的触发（事件本身）捆绑了上下文信息——如某人在某时某地做了某事——并且被生产者以消息的形式传送。而感兴趣的各方则可以通过一个共同的传输机制得知并消费该消息。\n没有代码清单","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"前面的章节介绍了消息传递作为解耦协作对象的一种方式。将通信变为异步、非阻塞的，而不是调用同步方法，这使得接收者能够在不同的执行上下文（比如不同的线程）中执行其工作。但为什么要止步于一台机器内的交互呢？消息传递在本地和远程交互中的工作原理相同。调度一个任务在本地机器上稍后运行，与发送一个网络包到不同的主机并在那里触发执行，并没有本质的区别。在这一章中，我们将探讨这个视角所提供的可能性，以及它对诸如延迟、吞吐量和消息丢失的概率等性能量化指标的影响。\n没有代码清单","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"上一章假定程序通常由多个组件构成，这些组件以某种方式分离：由不同的团队开发不同的功能领域；通过接口访问模块；模块被打包成容易被替换的方式；等等。在过去的几十年间，我们花费了大量的精力在编程语言中定义模块的语法和语义上，以及用于部署他们的库和基础设施。重要的问题是，我们应该如何划分一个问题，从而成功地解决它呢？\n本章无代码清单","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——有规划的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-有规划的失败处理","text":"你已经知道回弹性要求对系统进行分布和划分。分布式是唯一可以避免因单点故障（无论是硬件、软件或者人为失误）而导致全局失败的方式；划分可以隔离不同的分布式单元，使得任意单元的失败都不会扩散到其他单元上。总而言之，为了在失败之后恢复正常的功能，你需要将对失败作出反应的职责委托给一个监督者（supervisor）。\n没有代码清单","title":"第7章——有规划的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有界一致性 ·"},{"location":"/chapter-08/index.html#第8章-有界一致性","text":"分布式系统（distributed system）的某种定义是：一个各部分允许独立失败的系统。 反应式设计的本质是分布式的：你想对相互隔离的组件进行建模，并且只通过位置透明的消息传递进行交互，从而建立具有回弹性的监督层级结构。这意味着，最终产生的应用程序结构也将要面对分布式所带来的各种后果。在无状态系统中，这类后果主要与失败处理有关，恢复处理手段则如前一章所述。但是当系统需要维护状态时，就没有那么简单了。即使系统的每个部分都完美地工作，时间也是一个（可能导致失败的）因素。正如你在第 2 章中所学习到的，分布式会导致的其中一个后果就是无法保证强一致性（strong consistency）。在这一章中，你将学到有界一致性（delimited consistency），这是退而求其次的最优选。\n没有代码清单","title":"第8章——有界一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需使用非确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需使用非确定性","text":"这一章为全书最抽象的部分，对于初步理解后面章节来说，这一章的内容并非必需。你可以先直接跳到第10章看看，只要你保证之后还会回来。","title":"第9章——按需使用非确定性"},{"location":"/chapter-09/index.html#9-2-函数式反应式编程","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"9.2 函数式反应式编程"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"现在你已经建立了一套层级分明、封装明确的模块。这些模块可以呈现一个应用系统，你需要合理编排他们之间的互动以交付需求。前面章节贯穿而成的关键点是：模块之间只通过消息传递机制异步地进行通信。它们并不直接共享可变状态。一路上，你已经看到这种方式的诸多优点。它使得伸缩性和回弹性成为了可能，尤其是在与位置透明性相呼应的时候。而其对比方案，共享状态的并发，则比较难以正确地实现。\n没有代码清单","title":"第10章——消息流"},{"location":"/part3.html","text":"","title":"第三部分 设计模式 ·"},{"location":"/part3.html#第三部分-设计模式","text":"到目前为止，我们在讨论什么是反应式，以及为什么要应用反应式上已经花费了不少时间。现在是时候关注如何应用反应式了。 在第三部分中，我们将介绍一些可以帮助你实现反应式应用程序的设计模式。我们将首先讨论如何进行测试，以确保你的应用程序是反应式的，这样你就可以有信心接下来的的应用构建是都满足反应式契约的：无论从最小的功能组件，还是到整个跨数据中心部署结构。 然后，我们将深入探讨一些在反应式概念的各个维度上构建反应式系统的特定模式。\n在这一部分中，你将学习到以下内容：\n测试反应式系统，并特别强调异步测试 将内部和外部容错应用到你的应用程序中 管理反应式应用程序的资源 管理应用程序内部及应用程序之间的消息和数据流通 管理反应式系统的状态，以及持久化数据的过程\n对于每一个模式，我们将先以一个简短的段落介绍它的本质（以便回顾时作参考），接着介绍模式会出现在系统中的场景，并给出一个将模式应用到具体问题的详细示例。然后总结出每个模式所能解决的问题、典型特征和适用范围。\n第二部分讨论了搭建反应式系统的基础构建块，在你阅读后续章节时，值得经常回顾第二部分中的相关背景——以我们的经验，通常对一个主题进行二次攻关才会带来灵光乍现的瞬间","title":"第三部分 设计模式"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-11/index.html#11-3-异步测试","text":"代码清单 11-1 测试一个完全同步的翻译函数\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\ntranslate(input) should be(output)\nAsyncSpec.scala\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = translate(input)\n// what now?\nActorSpec.scala\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\n// when can we continue?\nAsyncSpecWithWhile.scala\nwhile (!future.isCompleted) Thread.sleep(50)\nAsyncSpecWithWhileLoopIterationsBounded.scala\nvar i = 20\nwhile (!future.isCompleted && i > 0) {\n  i -= 1\n  Thread.sleep(50)\n}\nif (i == 0) fail(\"translation was not received in time\")\n代码清单 11-2 等待结果的动作在翻译过程中同步阻塞\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval result = Await.result(translate(input), 1.second)\nresult should be(output)\n代码清单 11-3 使用 TestProbe 预期答复\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(1.second, output)\n代码清单 11-4 使用 TestProbe 接收调度程序的响应\nval probe = TestProbe()\nval start = Timestamp.now\nscheduler ! Schedule(probe.ref, \"tick\", 1.second)\nprobe.expectMsg(2.seconds, \"tick\")\nval stop = Timestamp.now\nval duration = stop - start\nassert(duration > 950.millis, \"tick came in early\")\nassert(duration < 1050.millis, \"tick came in late\")\n// when can we continue?\n代码清单 11-5 确定第 95 百分位的延迟\nval probe = TestProbe()\nval echo = echoService(\"keepSLA\")\nval N = 200\nval timings = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  echo ! Request(string, probe.ref)\n  probe.expectMsg(100.millis, s\"test run $i\", Response(string))\n  val stop = Timestamp.now\n  stop - start\n}\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 1.millisecond\nninetyfifthPercentile.toFiniteDuration should be <= SLA\n代码清单 11-6 用 Ask 模式并行地生成测试样本\nval echo = echoService(\"keepSLAfuture\")\nval N = 10000\nval timingFutures = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  (echo ? (Request(string, _))) collect {\n    case Response(`string`) ⇒ Timestamp.now - start\n  }\n}\nval futureOfTimings = Future.sequence(timingFutures)\nval timings = Await.result(futureOfTimings, 5.seconds)\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 500.milliseconds else 100.milliseconds\nninetyfifthPercentile.toFiniteDuration should be < SLA\n代码清单 11-7 使用自定义 Actor 来限制并行测试样本的数量\nval echo = echoService(\"keepSLAparallel\")\nval probe = TestProbe()\nval N = 10000\nval maxParallelism = 500\nval controller = system.actorOf(\n  Props[ParallelSLATester],\n  \"keepSLAparallelController\")\ncontroller ! TestSLA(echo, N, maxParallelism, probe.ref)\nval result = Try(probe.expectMsgType[SLAResponse]).recover {\n  case ae: AssertionError ⇒\n    controller ! AbortSLATest\n    val result = probe.expectMsgType[SLAResponse]\n    info(s\"controller timed out, state so far is $result\")\n    throw ae\n}.get\n// discard top 5%\nval sorted = result.timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 2.milliseconds\nninetyfifthPercentile should be < SLA\n代码清单 11-8 验证没有收到额外的消息\nimport scala.concurrent.duration._\nval scheduler = system.actorOf(Scheduler.props)\n\nval probe = TestProbe()\nscheduler ! ScheduleRepeatedly(probe.ref, 1.second, \"tick\")\nval token = probe.expectMsgType[SchedulerToken]\nprobe.expectMsg(1500.millis, \"tick\")\nscheduler ! CancelSchedule(token, probe.ref)\nprobe.expectMsg(100.millis, ScheduleCanceled)\nprobe.expectNoMessage(2.seconds)\n代码清单 11-9 对具有关联 ID 的请求匹配响应\nval ingestService = system.actorOf(DataIngester.props)\nval probe = TestProbe()\ningestService ! Retrieve(url, \"myID\", probe.ref)\nval replies = probe.receiveWhile(1.second) {\n  case r @ Record(\"myID\", _) ⇒ r\n}\nprobe.expectMsg(0.seconds, EOF)\n代码清单 11-10 强制同步执行：仅对非阻塞处理安全\nval tr = new TranslationService\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval ec = SynchronousEventLoop\nval future = tr.translate(input, ec)\nfuture.value.get should be(Success(output))\n代码清单 11-11 使用 CallingThreadDispatcher 来处理调用线程上的消息\nval translationService = system.actorOf(\n  TranslationService.props.withDispatcher(\"akka.test.calling-thread-dispatcher\"))\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(0.seconds, output)\n代码清单 11-12 将超时参数移到外部配置\nval tr = new TranslationService\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = tr.translate(input)\neventually {\n  future.value.get should be(Success(output))\n}\n代码清单 11-13 异步地处理响应，从而创建完全反应式的测试\nval echo = echoService()\nval N = 10000\nval maxParallelism = 500\nval controller = system.actorOf(\n  Props[ParallelSLATester],\n  \"keepSLAparallelController\")\nval future = controller ? (TestSLA(echo, N, maxParallelism, _))\nfor (SLAResponse(timings, outstanding) ← future) yield {\n  val sorted = timings.sorted\n  val ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\n  info(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\n  val SLA = if (Helpers.isCiTest) 25.milliseconds else 2.milliseconds\n  ninetyfifthPercentile should be > SLA\n}\n代码清单 11-14 使用 async 和 await 提高异步测试的可读性\nasync {\n  val input = \"Hur mår du?\"\n  val output = \"How are you?\"\n  await(translate(input).withTimeout(5.seconds)) should be(output)\n}\n代码清单 11-15 在 JavaScript 中测试翻译服务\ndescribe('Translator', function () {\n    describe('#translate()', function () {\n        it('should yield the correct result', function () {\n            return tr.translate('Hur mår du?')\n                .should.eventually.equal('How are you?');\n        })\n    })\n});\n代码清单 11-16 使用请求-响应工厂来生成测试流量\nval echo = echoService(\"keepSLAwithSupport\")\nval latencySupport = new LatencyTestSupport(system)\nval latencies = latencySupport.measure(count = 10000, maxParallelism = 500) { i ⇒\n  val message = s\"test$i\"\n  SingleResult((echo ? (Request(message, _))), Response(message))\n}\nval lat = Await.result(latencies, 20.seconds)\ninfo(s\"latency info: $lat\")\nlat.failureCount should be(0)\nval SLA = if (Helpers.isCiTest) 50.milliseconds else 10.milliseconds\nlat.quantile(0.99) should be < SLA\n代码清单 11-17 简单的翻译 API\ncase class TranslateV1(query: String, replyTo: ActorRef)\n代码清单 11-18 将更严格的类型添加到翻译 API\ncase class TranslateV2(\n  phrase:         String,\n  inputLanguage:  String,\n  outputLanguage: String,\n  replyTo:        ActorRef)\n\nsealed trait TranslationResponseV2\n\ncase class TranslationV2(\n  inputPhrase:    String,\n  outputPhrase:   String,\n  inputLanguage:  String,\n  outputLanguage: String)\n\ncase class TranslationErrorV2(\n  inputPhrase:    String,\n  inputLanguage:  String,\n  outputLanguage: String,\n  errorMessage:   String)\n代码清单 11-19 测试翻译版本适配器\nval v1 = TestProbe()\nval v2 = system.actorOf(propsV2(v1.ref))\nval client = TestProbe()\n\n// initiate a request to the adapter\nv2 ! TranslateV2(\"Hur mår du?\", \"sv\", \"en\", client.ref)\n\n// verify that the adapter asks the V1 service back-end\nval req1 = v1.expectMsgType[TranslateV1]\nreq1.query should be(\"sv:en:Hur mår du?\")\n\n// initiate a reply\nreq1.replyTo ! \"How are you?\"\n\n// verify that the adapter transforms it correctly\nclient.expectMsg(TranslationV2(\"Hur mår du?\", \"How are you?\", \"sv\", \"en\"))\n\n// now verify translation errors\nv2 ! TranslateV2(\"Hur är läget?\", \"sv\", \"en\", client.ref)\nval req2 = v1.expectMsgType[TranslateV1]\n// this implicitly verifies that no other communication happened with V1\nreq2.query should be(\"sv:en:Hur är läget?\")\nreq2.replyTo ! \"error:cannot parse input 'sv:en:Hur är läget?'\"\nclient.expectMsg(TranslationErrorV2(\"Hur är läget?\", \"sv\", \"en\",\n  \"cannot parse input 'sv:en:Hur är läget?'\"))\n\nv1.expectNoMessage(1.second)\n代码清单 11-20 模拟错误过程\ncase object ExpectNominal\n\ncase object ExpectError\n\ncase class Unexpected(msg: Any)\n\nclass MockV1(reporter: ActorRef) extends Actor {\n  def receive: Receive = initial\n\n  override def unhandled(msg: Any): Unit = {\n    reporter ! Unexpected(msg)\n  }\n\n  val initial: Receive = {\n    case ExpectNominal ⇒ context.become(expectingNominal)\n    case ExpectError   ⇒ context.become(expectingError)\n  }\n\n  def expectingNominal: Receive = {\n    case TranslateV1(\"sv:en:Hur mår du?\", replyTo) ⇒\n      replyTo ! \"How are you?\"\n      context.become(initial)\n  }\n\n  def expectingError: Receive = {\n    case TranslateV1(other, replyTo) ⇒\n      replyTo ! s\"error:cannot parse input '$other'\"\n      context.become(initial)\n  }\n}\n代码清单 11-21 测试正确的错误处理\nval asyncErrors = TestProbe()\nval v1 = system.actorOf(mockV1props(asyncErrors.ref))\nval v2 = system.actorOf(propsV2(v1))\nval client = TestProbe()\n\n// initiate a request to the adapter\nv1 ! ExpectNominal\nv2 ! TranslateV2(\"Hur mår du?\", \"sv\", \"en\", client.ref)\n\n// verify that the adapter transforms it correctly\nclient.expectMsg(TranslationV2(\"Hur mår du?\", \"How are you?\", \"sv\", \"en\"))\n\n// non-blocking check for async errors\nasyncErrors.expectNoMessage(0.seconds)\n\n// now verify translation errors\nv1 ! ExpectError\nv2 ! TranslateV2(\"Hur är läget?\", \"sv\", \"en\", client.ref)\nclient.expectMsg(TranslationErrorV2(\"Hur är läget?\", \"sv\", \"en\",\n  \"cannot parse input 'sv:en:Hur är läget?'\"))\n\n// final check for async errors\nasyncErrors.expectNoMessage(1.second)","title":"11.3 异步测试"},{"location":"/chapter-11/index.html#11-6-测试回弹性","text":"代码清单 11-22 要测试的基本 Actor\nclass MyActor extends Actor {\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒ throw new NullPointerException\n  }\n}\n代码清单 11-23 为被测 Actor 提供测试上下文\nclass StepParent extends Actor {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case thr ⇒ Restart\n  }\n\n  def receive: PartialFunction[Any, Unit] = {\n    case p: Props ⇒\n      sender ! context.actorOf(p, \"child\")\n  }\n}\n代码清单 11-24 在 StepParent 的上下文中测试 Actor\nclass StepParentSpec extends WordSpec with Matchers with BeforeAndAfterAll {\n  implicit val system: ActorSystem = ActorSystem()\n\n  \"An actor that throws an exception\" must {\n    \"Result in the supervisor returning a reference to that actor\" in {\n      val testProbe = TestProbe()\n      val parent = system.actorOf(Props[StepParent], \"stepParent\")\n      parent.tell(Props[MyActor], testProbe.ref)\n      val child = testProbe.expectMsgType[ActorRef]\n      // Test whatever we want in the actor\n    }\n  }\n\n  override def afterAll(): Unit = {\n    val terminated = system.terminate()\n    Await.ready(terminated, Duration.Inf)\n  }\n}\n代码清单 11-25 将失败报告给指定的 Actor\nclass FailureParent(failures: ActorRef) extends Actor {\n  val props: Props = Props[MyFailureParentActor]\n  val child: ActorRef = context.actorOf(props, \"child\")\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case f ⇒ failures ! f; Stop\n  }\n\n  def receive: PartialFunction[Any, Unit] = {\n    case msg ⇒ child forward msg\n  }\n}\n代码清单 11-26 在测试中移除监督\ncase object TestFailureParentMessage\n\nclass FailureParentSpec extends WordSpec with Matchers with BeforeAndAfterAll {\n  implicit val system: ActorSystem = ActorSystem()\n\n  \"Using a FailureParent\" must {\n    \"Result in failures being collected and returned\" in {\n      val failures = TestProbe()\n      val failureParent = system.actorOf(Props(new FailureParent(failures.ref)))\n      failureParent ! TestFailureParentMessage\n      failures.expectMsgType[NullPointerException]\n    }\n  }\n\n  override def afterAll(): Unit = {\n    val terminated = system.terminate()\n    Await.ready(terminated, Duration.Inf)\n  }\n}","title":"11.6 测试回弹性"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"在这一章中，你将学习到在设计应用程序时如何应对失败出现的可能性。我们将通过具体地构建一个具有回弹性的计算引擎来演示几个相应的模式，这个系统允许提交批处理作业，并在有着弹性调度的硬件资源上执行。我们将基于你在第6章和第7章所学习到的知识进行展开，因此，你可能想要回顾一下之前的内容。","title":"第12章——容错及恢复模式"},{"location":"/chapter-12/index.html#12-4-断路器模式","text":"代码清单 12-1 利用断路器使得失败组件有时间恢复\nprivate object StorageFailed extends RuntimeException\n\nprivate def sendToStorage(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  val f: Future[StorageStatus] = ???\n  f.map {\n    case StorageStatus.Failed => throw StorageFailed\n    case other => other\n  }\n}\n\nimport scala.concurrent.duration._\n\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  5,\n  300.millis,\n  30.seconds,\n)\n\ndef persist(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(sendToStorage(job))\n    .recover {\n      case StorageFailed => StorageStatus.Failed\n      case _: TimeoutException => StorageStatus.Unknown\n      case _: CircuitBreakerOpenException => StorageStatus.Failed\n    }\n}\n代码清单12-2 使用速率限制器保护组件\nimport scala.concurrent.Future\nimport scala.concurrent.duration.{ Deadline, FiniteDuration }\n\ncase object RateLimitExceeded extends RuntimeException\n\nclass RateLimiter(requests: Int, period: FiniteDuration) {\n  private val startTimes = {\n    val onePeriodAgo = Deadline.now - period\n    Array.fill(requests)(onePeriodAgo)\n  }\n  private var position = 0\n\n  private def lastTime = startTimes(position)\n\n  private def enqueue(time: Deadline): Unit = {\n    startTimes(position) = time\n    position += 1\n    if (position == requests) position = 0\n  }\n\n  def call[T](block: ⇒ Future[T]): Future[T] = {\n    val now = Deadline.now\n    if ((now - lastTime) < period) {\n      Future.failed(RateLimitExceeded)\n    } else {\n      enqueue(now)\n      block\n    }\n  }\n}\n代码清单12-3 断路器：限制来自同一个客户端的请求\nprivate val limiter = new RateLimiter(100, 2.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  limiter\n    .call(persist(job))\n    .recover {\n      case RateLimitExceeded ⇒ StorageStatus.Failed\n    }\n}\n代码清单12-4 门控一个客户端\nprivate val limiter = new RateLimiter(100, 2.seconds)\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  10, Duration.Zero, 10.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(limiter.call(persist(job)))\n    .recover {\n      case RateLimitExceeded              ⇒ StorageStatus.Failed\n      case _: CircuitBreakerOpenException ⇒ StorageStatus.Gated\n    }\n}","title":"12.4. 断路器模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-13/index.html#13-1-主动-被动复制模式","text":"Protocol\nsealed trait Command\n\nsealed trait Result\n\ncase class Put(key: String, value: JsValue, replyTo: ActorRef) extends Command\n\ncase class PutConfirmed(key: String, value: JsValue) extends Result\n\ncase class PutRejected(key: String, value: JsValue) extends Result\n\ncase class Get(key: String, replyTo: ActorRef) extends Command\n\ncase class GetResult(key: String, value: Option[JsValue]) extends Result\n代码清单 13-1 单例作为主动副本来接管\nclass Active(\n  localReplica:      ActorRef,\n  replicationFactor: Int,\n  maxQueueSize:      Int) extends Actor with Stash with ActorLogging {\n\n  private var theStore: Map[String, JsValue] = _\n  private var seqNr: Iterator[Int] = _\n\n  log.info(\"taking over from local replica\")\n  localReplica ! TakeOver(self)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case InitialState(m, s) ⇒\n      log.info(\"took over at sequence {}\", s)\n      theStore = m\n      seqNr = Iterator from s\n      context.become(running)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  val running: Receive = ???\n}\n代码清单 13-2 主动副本传播复制请求\nclass Active(\n  localReplica:      ActorRef,\n  replicationFactor: Int,\n  maxQueueSize:      Int) extends Actor with Stash with ActorLogging {\n\n  private val MaxOutstanding = maxQueueSize / 2\n\n  private var theStore: Map[String, JsValue] = _\n  private var seqNr: Iterator[Int] = _\n  private val toReplicate = Queue.empty[Replicate]\n  private var replicating = TreeMap.empty[Int, (Replicate, Int)]\n\n  private var rejected = 0\n\n  val timer: Cancellable =\n    context.system.scheduler.schedule(\n      1.second, 1.second, self, Tick)(context.dispatcher)\n\n  override def postStop(): Unit = timer.cancel()\n\n  log.info(\"taking over from local replica\")\n  localReplica ! TakeOver(self)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case InitialState(m, s) ⇒\n      log.info(\"took over at sequence {}\", s)\n      theStore = m\n      seqNr = Iterator from s\n      context.become(running)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  val running: Receive = {\n    case p @ Put(key, value, replyTo) ⇒\n      if (toReplicate.size < MaxOutstanding) {\n        toReplicate.enqueue(Replicate(seqNr.next, key, value, replyTo))\n        replicate()\n      } else {\n        rejected += 1\n        replyTo ! PutRejected(key, value)\n      }\n    case Get(key, replyTo) ⇒\n      replyTo ! GetResult(key, theStore get key)\n    case Tick ⇒\n      replicating.valuesIterator foreach {\n        case (replicate, count) ⇒ disseminate(replicate)\n      }\n      if (rejected > 0) {\n        log.info(\"rejected {} PUT requests\", rejected)\n        rejected = 0\n      }\n    case Replicated(confirm) ⇒\n      replicating.get(confirm) match {\n        case None ⇒ // already removed\n        case Some((rep, 1)) ⇒\n          replicating -= confirm\n          theStore += rep.key -> rep.value\n          rep.replyTo ! PutConfirmed(rep.key, rep.value)\n        case Some((rep, n)) ⇒\n          replicating += confirm -> (rep, n - 1)\n      }\n      replicate()\n  }\n\n  private def replicate(): Unit =\n    if (replicating.size < MaxOutstanding && toReplicate.nonEmpty) {\n      val r = toReplicate.dequeue()\n      replicating += r.seq -> (r, replicationFactor)\n      disseminate(r)\n    }\n\n  private def disseminate(r: Replicate): Unit = {\n    val req = r.copy(replyTo = self)\n    val members = Cluster(context.system).state.members\n    members.foreach(m ⇒ replicaOn(m.address) ! req)\n  }\n\n  private def replicaOn(addr: Address): ActorSelection =\n    context.actorSelection(localReplica.path.toStringWithAddress(addr))\n}\n代码清单 13-3 通过将JSON文件写入到本地磁盘来实现持久化\nimport java.io.File\n\nimport akka.actor.ActorRef\nimport play.api.libs.json.{ JsValue, Json, OFormat }\nimport sbt.io.IO\n\nobject Persistence {\n\n  case class Database(seq: Int, kv: Map[String, JsValue])\n\n  object Database {\n    implicit val format: OFormat[Database] = Json.format[Database]\n  }\n\n  def persist(name: String, seq: Int, kv: Map[String, JsValue]): Unit = {\n    val bytes = Json.stringify(Json.toJson(Database(seq, kv)))\n    val current = new File(s\"./theDataBase-$name.json\")\n    val next = new File(s\"./theDataBase-$name.json.new\")\n    IO.write(next, bytes)\n    IO.move(next, current) // atomically update the database\n  }\n\n  def readPersisted(name: String): Database = {\n    val file = new File(s\"theDataBase-$name.json\")\n    if (file.exists()) Json.parse(IO.read(file)).as[Database]\n    else Database(0, Map.empty)\n  }\n}\n代码清单 13-4 被动副本追踪它们是否是最新的版本\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = Queue.empty[Replicate]\n\n  val name: String =\n    Cluster(context.system).selfAddress.toString.replaceAll(\"[:/]\", \"_\")\n\n  def receive: Receive = readPersisted(name) match {\n    case Database(s, kv) ⇒\n      log.info(\"started at sequence {}\", s)\n      upToDate(kv, s + 1)\n  }\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    case TakeOver(active) ⇒\n      log.info(\"active replica starting at sequence {}\", expectedSeq)\n      active ! InitialState(theStore, expectedSeq)\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒\n      replyTo ! Replicated(s)\n    case r: Replicate if r.seq == expectedSeq ⇒\n      val nextStore = theStore + (r.key -> r.value)\n      persist(name, expectedSeq, nextStore)\n      r.replyTo ! Replicated(r.seq)\n      applied.enqueue(r)\n      context.become(upToDate(nextStore, expectedSeq + 1))\n    case r: Replicate ⇒\n      if (r.seq - expectedSeq > maxLag)\n        fallBehind(expectedSeq, TreeMap(r.seq -> r))\n      else\n        missingSomeUpdates(theStore, expectedSeq, Set.empty, TreeMap(r.seq -> r))\n    case GetSingle(s, replyTo) ⇒\n      log.info(\"GetSingle from {}\", replyTo)\n      if (applied.nonEmpty && applied.head.seq <= s && applied.last.seq >= s)\n        replyTo ! applied.find(_.seq == s).get\n      else if (s < expectedSeq) replyTo ! InitialState(theStore, expectedSeq)\n    case GetFull(replyTo) ⇒\n      log.info(\"sending full info to {}\", replyTo)\n      replyTo ! InitialState(theStore, expectedSeq)\n  }\n\n  def fallBehind(\n    expectedSeq: Int,\n    _waiting:    TreeMap[Int, Replicate]): Unit = ???\n\n  def missingSomeUpdates(\n    theStore:        Map[String, JsValue],\n    expectedSeq:     Int,\n    prevOutstanding: Set[Int],\n    waiting:         TreeMap[Int, Replicate]): Unit = ???\n}\n代码清单 13-5 被动副本在滞后过多时请求一份全量更新\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = Queue.empty[Replicate]\n  private var awaitingInitialState = Option.empty[ActorRef]\n\n  val name: String =\n    Cluster(context.system).selfAddress.toString.replaceAll(\"[:/]\", \"_\")\n  val cluster = Cluster(context.system)\n  val random = new Random\n\n  private var tickTask = Option.empty[Cancellable]\n\n  def scheduleTick(): Unit = {\n    tickTask foreach (_.cancel())\n    tickTask = Some(context.system.scheduler.scheduleOnce(\n      askAroundInterval, self, DoConsolidate)(context.dispatcher))\n  }\n\n  def receive: Receive = readPersisted(name) match {\n    case Database(s, kv) ⇒\n      log.info(\"started at sequence {}\", s)\n      upToDate(kv, s + 1)\n  }\n\n  def caughtUp(theStore: Map[String, JsValue], expectedSeq: Int): Unit = {\n    awaitingInitialState foreach (_ ! InitialState(theStore, expectedSeq))\n    awaitingInitialState = None\n    context.become(upToDate(theStore, expectedSeq))\n  }\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    // Cases shown previously elided\n    case TakeOver(active)                                   ⇒ ???\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒ ???\n    case r: Replicate if r.seq == expectedSeq               ⇒ ???\n    case r: Replicate                                       ⇒ ???\n    case GetSingle(s, replyTo)                              ⇒ ???\n    case GetFull(replyTo) ⇒\n      log.info(\"sending full info to {}\", replyTo)\n      replyTo ! InitialState(theStore, expectedSeq)\n  }\n\n  def fallBehind(expectedSeq: Int, _waiting: TreeMap[Int, Replicate]): Unit = {\n    askAroundFullState()\n    scheduleTick()\n    var waiting = _waiting\n    context.become {\n      case Replicate(s, _, _, replyTo) if s < expectedSeq ⇒\n        replyTo ! Replicated(s)\n      case r: Replicate ⇒\n        waiting += (r.seq -> r)\n      case TakeOver(active) ⇒\n        log.info(\n          \"delaying active replica takeOver, at seq {} while highest is {}\",\n          expectedSeq, waiting.lastKey)\n        awaitingInitialState = Some(active)\n      case InitialState(m, s) if s > expectedSeq ⇒\n        log.info(\n          \"received newer state at sequence {} (was at {})\", s, expectedSeq)\n        persist(name, s, m)\n        waiting.to(s).valuesIterator foreach (r ⇒ r.replyTo ! Replicated(r.seq))\n        val nextWaiting = waiting.from(expectedSeq)\n        consolidate(m, s + 1, Set.empty, nextWaiting)\n      case DoConsolidate ⇒\n        askAroundFullState()\n        scheduleTick()\n    }\n  }\n\n  private def consolidate(\n    theStore:    Map[String, JsValue],\n    expectedSeq: Int,\n    askedFor:    Set[Int],\n    waiting:     TreeMap[Int, Replicate]): Unit = ???\n\n  private def getMembers(n: Int): Seq[Address] = {\n    // using .iterator to avoid one intermediate collection to be created\n    random.shuffle(cluster.state.members.iterator.map(_.address).toSeq).take(n)\n  }\n\n  private def askAroundFullState(): Unit = {\n    log.info(\"asking for full data\")\n    getMembers(1).foreach(addr ⇒ replicaOn(addr) ! GetFull(self))\n  }\n\n  private def replicaOn(addr: Address): ActorSelection =\n    context.actorSelection(self.path.toStringWithAddress(addr))\n}\n代码清单 13-6 计算直接可应用的队列前段的长度\nprivate val matches = (p: (Int, Int)) ⇒ p._1 == p._2\n\nprivate def consolidate(\n  theStore:    Map[String, JsValue],\n  expectedSeq: Int,\n  askedFor:    Set[Int],\n  waiting:     TreeMap[Int, Replicate]): Unit = {\n\n  // calculate applicable prefix length\n  val prefix = waiting.keysIterator\n    .zip(Iterator from expectedSeq).takeWhile(matches).size\n\n  val nextStore = waiting.valuesIterator.take(prefix)\n    .foldLeft(theStore) { (store, replicate) ⇒\n      persist(name, replicate.seq, theStore)\n      replicate.replyTo ! Replicated(replicate.seq)\n      applied.enqueue(replicate)\n      store + (replicate.key -> replicate.value)\n    }\n  val nextWaiting = waiting.drop(prefix)\n  val nextExpectedSeq = expectedSeq + prefix\n\n  // cap the size of the applied buffer\n  applied.drop(Math.max(0, applied.size - maxLag))\n\n  if (nextWaiting.nonEmpty) {\n    // check if we fell behind by too much\n    if (nextWaiting.lastKey - nextExpectedSeq > maxLag)\n      fallBehind(nextExpectedSeq, nextWaiting)\n    else missingSomeUpdates(nextStore, nextExpectedSeq, askedFor, nextWaiting)\n  } else caughtUp(nextStore, nextExpectedSeq)\n}\n代码清单 13-7 确定更新队列里的数据缺口是否可以被一一填补\nclass Passive(\n  askAroundCount:    Int,\n  askAroundInterval: FiniteDuration,\n  maxLag:            Int) extends Actor with ActorLogging {\n\n  private val applied = Queue.empty[Replicate]\n  private var awaitingInitialState = Option.empty[ActorRef]\n\n  // ... Initialization elided\n  def receive: Receive = ???\n\n  def upToDate(theStore: Map[String, JsValue], expectedSeq: Int): Receive = {\n    case TakeOver(active)                                   ⇒ ???\n    case Replicate(s, _, _, replyTo) if s - expectedSeq < 0 ⇒ ???\n    case r: Replicate if r.seq == expectedSeq               ⇒ ???\n    case r: Replicate                                       ⇒ ???\n    case GetFull(replyTo)                                   ⇒ ???\n    case GetSingle(s, replyTo) ⇒\n      log.info(\"GetSingle from {}\", replyTo)\n      if (applied.nonEmpty && applied.head.seq <= s && applied.last.seq >= s)\n        replyTo ! applied.find(_.seq == s).get\n      else if (s < expectedSeq) replyTo ! InitialState(theStore, expectedSeq)\n  }\n\n  def missingSomeUpdates(\n    theStore:        Map[String, JsValue],\n    expectedSeq:     Int,\n    prevOutstanding: Set[Int],\n    waiting:         TreeMap[Int, Replicate]): Unit = {\n\n    val askFor = (expectedSeq to waiting.lastKey).iterator\n      .filterNot(seq ⇒ waiting.contains(seq) ||\n        prevOutstanding.contains(seq)).toList\n    askFor foreach askAround\n    if (prevOutstanding.isEmpty) scheduleTick()\n    val outstanding = prevOutstanding ++ askFor\n    context.become {\n      case Replicate(s, _, _, replyTo) if s < expectedSeq ⇒\n        replyTo ! Replicated(s)\n      case r: Replicate ⇒ consolidate(theStore, expectedSeq,\n        outstanding - r.seq, waiting + (r.seq -> r))\n      case TakeOver(active) ⇒\n        log.info(\n          \"delaying active replica takeOver, at seq {} while highest is {}\",\n          expectedSeq, waiting.lastKey)\n        awaitingInitialState = Some(active)\n      case GetSingle(s, replyTo) ⇒\n        log.info(\"GetSingle from {}\", replyTo)\n        if (applied.nonEmpty && applied.head.seq <= s && applied.last.seq >= s)\n          replyTo ! applied.find(_.seq == s).get\n        else if (s < expectedSeq) replyTo ! InitialState(theStore, expectedSeq)\n      case GetFull(replyTo) ⇒\n        log.info(\"sending full info to {}\", replyTo)\n        replyTo ! InitialState(theStore, expectedSeq)\n      case DoConsolidate ⇒\n        outstanding foreach askAround\n        scheduleTick()\n    }\n  }\n\n  private def askAround(seq: Int): Unit = {\n    log.info(\"asking around for sequence number {}\", seq)\n    getMembers(askAroundCount)\n      .foreach(addr ⇒ replicaOn(addr) ! GetSingle(seq, self))\n  }\n\n  // ... Other helpers elided\n  private def consolidate(\n    theStore:    Map[String, JsValue],\n    expectedSeq: Int,\n    askedFor:    Set[Int],\n    waiting:     TreeMap[Int, Replicate]): Unit = ???\n\n  private def getMembers(n: Int): Seq[Address] = ???\n\n  private def replicaOn(addr: Address): ActorSelection = ???\n\n  def scheduleTick(): Unit = ???\n\n}","title":"13.1 主动-被动复制模式"},{"location":"/chapter-13/index.html#13-2-多主复制模式","text":"代码清单 13-8 使用 CKite 来实现键值存储\nclass KVStore extends StateMachine {\n  private var map = Map[String, String]()\n  private var lastIndex: Long = 0\n\n  def applyWrite = {\n    case (index, Put(key: String, value: String)) ⇒ {\n      map.put(key, value)\n      lastIndex = index\n      value\n    }\n  }\n\n  def applyRead = {\n    case Get(key) ⇒ map.get(key)\n  }\n\n  def getLastAppliedIndex: Long = lastIndex\n\n  def restoreSnapshot(byteBuffer: ByteBuffer) = {\n    map = Serializer.deserialize[Map[String, String]](byteBuffer.array())\n  }\n\n  def takeSnapshot(): ByteBuffer = ByteBuffer.wrap(Serializer.serialize(map))\n\n}\n代码清单 13-9 按照复制状态机来实例化KVStore\nobject KVStoreBootstrap extends App {\n  val ckite =\n    CKiteBuilder()\n      .stateMachine(new KVStore())\n      .rpc(FinagleThriftRpc)\n      .storage(MapDBStorage())\n      .build\n  ckite.start()\n\n  HttpServer(ckite).start()\n}\nckite api\nval consistentRead = ckite.read(Get(key))\nval possibleStaleRead = ckite.readLocal(Get(key))\nval write = ckite.write(Put(key, value))\n代码清单 13-10 图13-1中图形的代码表示\nfinal case class Status(name: String)(\n  _pred: ⇒ Set[Status], _succ: ⇒ Set[Status]) extends ReplicatedData {\n\n  type T = Status\n\n  def merge(that: Status): Status = mergeStatus(this, that)\n\n  @volatile lazy val predecessors: Set[Status] = _pred\n  @volatile lazy val successors: Set[Status] = _succ\n\n}\n\nval New: Status =\n  Status(\"new\")(Set.empty, Set(Scheduled, Cancelled))\nval Scheduled: Status =\n  Status(\"scheduled\")(Set(New), Set(Executing, Cancelled))\nval Executing: Status =\n  Status(\"executing\")(Set(Scheduled), Set(Aborted, Finished))\nval Finished: Status =\n  Status(\"finished\")(Set(Executing, Aborted), Set.empty)\nval Cancelled: Status =\n  Status(\"cancelled\")(Set(New, Scheduled), Set(Aborted))\nval Aborted: Status =\n  Status(\"aborted\")(Set(Cancelled, Executing), Set(Finished))\n代码清单 13-11 合并两个状态来产生第三个合并后的状态\ndef mergeStatus(left: Status, right: Status): Status = {\n  /*\n   * Keep the left Status in hand and determine whether it is a predecessor of\n   * the candidate, moving on to the candidate’s successor if not successful.\n   * The list of exclusions is used to avoid performing already determined\n   * unsuccessful comparisons again.\n   */\n  def innerLoop(candidate: Status, exclude: Set[Status]): Status =\n    if (isSuccessor(candidate, left, exclude)) {\n      candidate\n    } else {\n      val nextExclude = exclude + candidate\n      val branches =\n        candidate.successors.map(succ ⇒ innerLoop(succ, nextExclude))\n      branches.reduce((l, r) ⇒ if (isSuccessor(l, r, nextExclude)) r else l)\n    }\n\n  def isSuccessor(\n    candidate: Status,\n    fixed:     Status, exclude: Set[Status]): Boolean =\n    if (candidate == fixed) true\n    else {\n      val toSearch = candidate.predecessors -- exclude\n      toSearch.exists(pred ⇒ isSuccessor(pred, fixed, exclude))\n    }\n\n  innerLoop(right, Set.empty)\n}\n代码清单 13-12 使用 Akka Distributed Data 来传播状态变更\nclass ClientInterface extends Actor with ActorLogging {\n  val replicator: ActorRef = DistributedData(context.system).replicator\n  implicit val cluster: _root_.akka.cluster.Cluster = Cluster(context.system)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Submit(job) ⇒\n      log.info(\"submitting job {}\", job)\n      replicator ! Replicator.Update(StorageComponent, ORMap.empty[Status],\n        Replicator.WriteMajority(5.seconds),\n        Some(s\"submit $job\"))(_ + (job -> New))\n    case Cancel(job) ⇒\n      log.info(\"cancelling job {}\", job)\n      replicator ! Replicator.Update(StorageComponent, ORMap.empty[Status],\n        Replicator.WriteMajority(5.seconds),\n        Some(s\"cancel $job\"))(_ + (job -> Cancelled))\n    case r: Replicator.UpdateResponse[_] ⇒\n      log.info(\"received update result: {}\", r)\n    case PrintStatus ⇒\n      replicator ! Replicator.Get(\n        StorageComponent,\n        Replicator.ReadMajority(5.seconds))\n    case g: Replicator.GetSuccess[_] ⇒\n      log.info(\"overall status: {}\", g.get(StorageComponent))\n  }\n}\n代码清单 13-13 引入对于任务的请求标志\nclass Executor extends Actor with ActorLogging {\n  val replicator: ActorRef = DistributedData(context.system).replicator\n  implicit val cluster: _root_.akka.cluster.Cluster = Cluster(context.system)\n\n  var lastState = Map.empty[String, Status]\n\n  replicator ! Replicator.Subscribe(StorageComponent, self)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Execute(job) ⇒\n      log.info(\"executing job {}\", job)\n      replicator ! Replicator.Update(\n        StorageComponent, ORMap.empty[Status],\n        Replicator.WriteMajority(5.seconds), Some(job)) { map ⇒\n          require(map.get(job) == Some(New))\n          map + (job -> Executing)\n        }\n    case Finish(job) ⇒\n      log.info(\"job {} finished\", job)\n      replicator ! Replicator.Update(\n        StorageComponent, ORMap.empty[Status],\n        Replicator.WriteMajority(5.seconds))(_ + (job -> Finished))\n    case Replicator.UpdateSuccess(StorageComponent, Some(job)) ⇒\n      log.info(\"starting job {}\", job)\n    case r: Replicator.UpdateResponse[_] ⇒\n      log.info(\"received update result: {}\", r)\n    case ch: Replicator.Changed[_] ⇒\n      val current = ch.get(StorageComponent).entries\n      for {\n        (job, status) ← current.iterator\n        if (status == Aborted)\n        if (lastState.get(job) != Some(Aborted))\n      } log.info(\"aborting job {}\", job)\n      lastState = current\n  }\n}","title":"13.2 多主复制模式"},{"location":"/chapter-13/index.html#13-3-主动-主动复制模式","text":"代码清单 13-14 用无协调工作的实现来开始主动-主动复制模式\nprivate case class SeqCommand(seq: Int, cmd: Command, replyTo: ActorRef)\n\nprivate case class SeqResult(\n  seq:     Int,\n  res:     Result,\n  replica: ActorRef,\n  replyTo: ActorRef)\n\nprivate case class SendInitialData(toReplica: ActorRef)\n\nprivate case class InitialData(map: Map[String, JsValue])\n\nclass Replica extends Actor with Stash {\n  var map = Map.empty[String, JsValue]\n\n  def receive: PartialFunction[Any, Unit] = {\n    case InitialData(m) ⇒\n      map = m\n      context.become(initialized)\n      unstashAll()\n    case _ ⇒ stash()\n  }\n\n  def initialized: Receive = {\n    case SeqCommand(seq, cmd, replyTo) ⇒\n      // tracking of sequence numbers and resends is elided here\n      cmd match {\n        case Put(key, value, r) ⇒\n          map += key -> value\n          replyTo ! SeqResult(seq, PutConfirmed(key, value), self, r)\n        case Get(key, r) ⇒\n          replyTo ! SeqResult(seq, GetResult(key, map get key), self, r)\n      }\n    case SendInitialData(toReplica) ⇒ toReplica ! InitialData(map)\n  }\n}\n代码清单 13-15 封装对于单个客户端请求的知悉情况\nprivate sealed trait ReplyState {\n  def deadline: Deadline\n\n  def missing: Set[ActorRef]\n\n  def add(res: SeqResult): ReplyState\n\n  def isFinished: Boolean = missing.isEmpty\n}\n\nprivate case class Unknown(\n  deadline: Deadline, replies: Set[SeqResult],\n  missing: Set[ActorRef], quorum: Int) extends ReplyState {\n\n  override def add(res: SeqResult): ReplyState = {\n    val nextReplies = replies + res\n    val nextMissing = missing - res.replica\n    if (nextReplies.size >= quorum) {\n      val answer =\n        replies.toSeq.groupBy(_.res)\n          .collectFirst { case (k, s) if s.size >= quorum ⇒ s.head }\n\n      if (answer.isDefined) {\n        val right = answer.get\n        val wrong = replies.collect {\n          case SeqResult(_, res, replica, _) if res != right ⇒ replica\n        }\n        Known(deadline, right, wrong, nextMissing)\n      } else if (nextMissing.isEmpty) Known.fromUnknown(deadline, nextReplies)\n      else Unknown(deadline, nextReplies, nextMissing, quorum)\n    } else Unknown(deadline, nextReplies, nextMissing, quorum)\n  }\n}\n\nprivate case class Known(\n  deadline: Deadline, reply: SeqResult,\n  wrong: Set[ActorRef], missing: Set[ActorRef]) extends ReplyState {\n\n  override def add(res: SeqResult): ReplyState = {\n    val nextWrong = if (res.res == reply.res) wrong else wrong + res.replica\n    Known(deadline, reply, nextWrong, missing - res.replica)\n  }\n}\n\nprivate object Known {\n  def fromUnknown(deadline: Deadline, replies: Set[SeqResult]): Known = {\n    // did not reach consensus on this one, pick simple majority\n    val counts = replies.groupBy(_.res)\n    val biggest = counts.iterator.map(_._2.size).max\n    val winners = counts.collectFirst {\n      case (res, win) if win.size == biggest ⇒ win\n    }.get\n    val losers = (replies -- winners).map(_.replica)\n    Known(deadline, winners.head, losers, Set.empty)\n  }\n}\n代码清单 13-16 将副本当作子Actor管理\nclass Coordinator(N: Int) extends Actor {\n  private var replicas = (1 to N).map(_ ⇒ newReplica()).toSet\n  private val seqNr = Iterator from 0\n  private var replies = TreeMap.empty[Int, ReplyState]\n  private var nextReply = 0\n\n  override def supervisorStrategy: SupervisorStrategy =\n    SupervisorStrategy.stoppingStrategy\n\n  private def newReplica(): ActorRef =\n    context.watch(context.actorOf(Replica.props))\n\n  // schedule timeout messages for quiescent periods\n  context.setReceiveTimeout(1.second)\n\n  def receive: PartialFunction[Any, Unit] = ({\n    case cmd: Command ⇒\n      val c = SeqCommand(seqNr.next, cmd, self)\n      replicas foreach (_ ! c)\n      replies += c.seq -> Unknown(5 seconds fromNow, Set.empty,\n        replicas, (replicas.size + 1) / 2)\n    case res: SeqResult if replies.contains(res.seq) &&\n      replicas.contains(res.replica) ⇒\n      val prevState = replies(res.seq)\n      val nextState = prevState.add(res)\n      replies += res.seq -> nextState\n    case Terminated(ref) ⇒\n      replaceReplica(ref, terminate = false)\n    case ReceiveTimeout ⇒\n  }: Receive) andThen { _ ⇒\n    doTimeouts()\n    sendReplies()\n    evictFinished()\n  }\n\n  private def doTimeouts(): Unit = {\n    val now = Deadline.now\n    val expired = replies.iterator.takeWhile(_._2.deadline <= now)\n    for ((seq, state) ← expired) {\n      state match {\n        case Unknown(deadline, received, _, _) ⇒\n          val forced = Known.fromUnknown(deadline, received)\n          replies += seq -> forced\n        case Known(deadline, reply, wrong, missing) ⇒\n          replies += seq -> Known(deadline, reply, wrong, Set.empty)\n      }\n    }\n  }\n\n\n  @tailrec private def sendReplies(): Unit =\n    replies.get(nextReply) match {\n      case Some(k @ Known(_, reply, _, _)) ⇒\n        reply.replyTo ! reply.res\n        nextReply += 1\n        sendReplies()\n      case _ ⇒\n    }\n\n\n  @tailrec private def evictFinished(): Unit =\n    replies.headOption match {\n      case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished ⇒\n        wrong foreach (replaceReplica(_, terminate = true))\n        replies -= seq\n        evictFinished()\n      case _ ⇒\n    }\n\n  private def replaceReplica(r: ActorRef, terminate: Boolean): Unit =\n    if (replicas contains r) {\n      replicas -= r\n      if (terminate) r ! PoisonPill\n      val replica = newReplica()\n      replicas.head ! SendInitialData(replica)\n      replicas += replica\n    }\n\n}\n代码清单 13-17 按序发送回复\n@tailrec private def sendReplies(): Unit =\n  replies.get(nextReply) match {\n    case Some(k @ Known(_, reply, _, _)) ⇒\n      reply.replyTo ! reply.res\n      nextReply += 1\n      sendReplies()\n    case _ ⇒\n  }\n代码清单 13-18 一旦timeout，就强迫将“missing”回复转为“known”回复\nprivate def doTimeouts(): Unit = {\n  val now = Deadline.now\n  val expired = replies.iterator.takeWhile(_._2.deadline <= now)\n  for ((seq, state) ← expired) {\n    state match {\n      case Unknown(deadline, received, _, _) ⇒\n        val forced = Known.fromUnknown(deadline, received)\n        replies += seq -> forced\n      case Known(deadline, reply, wrong, missing) ⇒\n        replies += seq -> Known(deadline, reply, wrong, Set.empty)\n    }\n  }\n}\n代码清单 13-19 终止并替换未完成的副本\n@tailrec private def evictFinished(): Unit =\n  replies.headOption match {\n    case Some((seq, k @ Known(_, _, wrong, _))) if k.isFinished ⇒\n      wrong foreach (replaceReplica(_, terminate = true))\n      replies -= seq\n      evictFinished()\n    case _ ⇒\n  }\n\nprivate def replaceReplica(r: ActorRef, terminate: Boolean): Unit =\n  if (replicas contains r) {\n    replicas -= r\n    if (terminate) r ! PoisonPill\n    val replica = newReplica()\n    replicas.head ! SendInitialData(replica)\n    replicas += replica\n  }","title":"13.3 主动-主动复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"大多数系统都面临着一个共同的问题，那就是你需要管理或展现资源：文件存储空间、计算能力、对数据库或 Web API 的访问、如打印机和读卡器等物理设备，诸如此类。你所创建的某个组件，可能会独自为系统的其余部分提供某种资源，又或者你可能需要将其与外部资源整合。在这一章中，我们将讨论处理反应式应用程序中资源的模式。我们将着重讨论以下几种模式：","title":"第14章——资源管理模式"},{"location":"/chapter-14/index.html#14-1-资源封装模式","text":"代码清单 14-1 亚马逊EC2实例作为工作者节点\npublic Instance startInstance(AWSCredentials credentials) {\n  AmazonEC2Client amazonEC2Client = new AmazonEC2Client(credentials);\n\n  RunInstancesRequest runInstancesRequest =\n      new RunInstancesRequest()\n          .withImageId(\"\")\n          .withInstanceType(\"m1.small\")\n          .withMinCount(1)\n          .withMaxCount(1);\n\n  RunInstancesResult runInstancesResult =\n      amazonEC2Client.runInstances(runInstancesRequest);\n\n  Reservation reservation = runInstancesResult.getReservation();\n  List<Instance> instances = reservation.getInstances();\n\n  // there will be exactly one instance in this list, otherwise\n  // runInstances() would have thrown an exception\n  return instances.get(0);\n}\n代码清单 14-2 将EC2节点提升到一个Future中，从而简化失败处理过程\nprivate ExecutionContext executionContext;\nprivate CircuitBreaker circuitBreaker;\n\npublic Future<Instance> startInstanceAsync(AWSCredentials credentials) {\n  Future<Instance> f = circuitBreaker.callWithCircuitBreaker(\n    () -> Futures.future(\n      () -> startInstance(credentials), executionContext));\n\n  PartialFunction<Throwable, Future<Instance>> recovery =\n    new PFBuilder<Throwable, Future<Instance>>()\n      .match(AmazonClientException.class,\n        ex -> ex.isRetryable(),\n        ex -> startInstanceAsync(credentials))\n      .build();\n\n  return f.recoverWith(recovery, executionContext);\n}\n代码清单 14-3 通过桥接客户端代码执行亚马逊的异步客户端\npublic Future<RunInstancesResult> runInstancesAsync(\n    RunInstancesRequest request,\n    AmazonEC2Async client) {\n\n  Promise<RunInstancesResult> promise = Futures.promise();\n  client.runInstancesAsync(\n      request,\n      new AsyncHandler<RunInstancesRequest, RunInstancesResult>() {\n\n        @Override\n        public void onSuccess(RunInstancesRequest request,\n            RunInstancesResult result) {\n          promise.success(result);\n        }\n\n        @Override\n        public void onError(Exception exception) {\n          promise.failure(exception);\n        }\n      });\n  return promise.future();\n}\n代码清单 14-4 关闭 EC2 实例\npublic Future<TerminateInstancesResult> terminateInstancesAsync(\n  AmazonEC2Client client, Instance... instances) {\n\n  List<String> ids = Arrays\n    .stream(instances)\n    .map(i -> i.getInstanceId())\n    .collect(Collectors.toList());\n  TerminateInstancesRequest request = new TerminateInstancesRequest(ids);\n\n  Future<TerminateInstancesResult> f =\n    circuitBreaker.callWithCircuitBreaker(\n      () -> Futures.future(() -> client.terminateInstances(request),\n        executionContext));\n\n  PartialFunction<Throwable, Future<TerminateInstancesResult>> recovery =\n    new PFBuilder<Throwable, Future<TerminateInstancesResult>>()\n      .match(AmazonClientException.class,\n        ex -> ex.isRetryable(),\n        ex -> terminateInstancesAsync(client, instances))\n      .build();\n\n  return f.recoverWith(recovery, executionContext);\n}\n代码清单 14-5 执行组件和看作工作者节点的 Actor 通信\nclass WorkerNode extends AbstractActor {\n  private final Cancellable checkTimer;\n\n  public WorkerNode(InetAddress address, FiniteDuration checkInterval) {\n    checkTimer =\n        getContext()\n            .system()\n            .scheduler()\n            .schedule(checkInterval, checkInterval, self(),\n                DoHealthCheck.instance,\n                getContext().dispatcher(), self());\n  }\n\n  @Override\n  public Receive createReceive() {\n    List<WorkerNodeMessage> msgs = new ArrayList<>();\n    return receiveBuilder().match(WorkerNodeMessage.class, msgs::add)\n      .match(DoHealthCheck.class, dhc -> { /* perform check */ })\n      .match(Shutdown.class, s -> {\n        msgs.stream().forEach(\n          msg -> msg.replyTo().tell(\n            new WorkerCommandFailed(\"shutting down\", msg.id()), self()));\n        /* ask Resource Pool to shut down this instance */\n      })\n      .match(WorkerNodeReady.class, wnr -> {\n        /* send msgs to the worker */\n        getContext().become(initialized());\n      })\n      .build();\n  }\n\n  private PartialFunction<Object, BoxedUnit> initialized() {\n    /* forward commands and deal with responses from worker node */\n    return null;\n  }\n\n  @Override\n  public void postStop() {\n    checkTimer.cancel();\n  }\n}","title":"14.1 资源封装模式"},{"location":"/chapter-14/index.html#14-2-资源借贷模式","text":"代码清单 14-6 分离资源和任务的管理\nclass WorkerNodeForExecution extends AbstractActor {\n\n  @Override\n  public Receive createReceive() {\n    List<WorkerNodeMessage> msgs = new ArrayList<>();\n    return receiveBuilder()\n      .match(WorkerNodeMessage.class, msgs::add)\n      .match(Shutdown.class, s -> {\n        msgs.stream().forEach(msg -> {\n          WorkerCommandFailed failMsg =\n            new WorkerCommandFailed(\"shutting down\", msg.id());\n          msg.replyTo().tell(failMsg, self());\n        });\n      })\n      .match(WorkerNodeReady.class, wnr -> {\n        getContext().become(initialized());\n      })\n      .build();\n  }\n\n  private PartialFunction<Object, BoxedUnit> initialized() {\n    /* forward commands and deal with responses from worker node */\n    return null;\n  }\n}\n\nclass WorkNodeForResourcePool extends AbstractActor {\n  private final Cancellable checkTimer;\n\n  public WorkNodeForResourcePool(InetAddress address,\n      FiniteDuration checkInterval) {\n    checkTimer = getContext().system().scheduler()\n        .schedule(checkInterval, checkInterval, self(),\n            DoHealthCheck.instance, getContext().dispatcher(), self());\n\n  }\n\n  @Override\n  public Receive createReceive() {\n    return receiveBuilder()\n      .match(DoHealthCheck.class, dhc -> { /* perform check */ })\n      .match(Shutdown.class, s -> {/* Cleans up this resource */})\n      .build();\n  }\n\n  @Override\n  public void postStop() {\n    checkTimer.cancel();\n  }\n}","title":"14.2 资源借贷模式"},{"location":"/chapter-14/index.html#14-3-复杂命令模式","text":"代码清单 14-7 批处理作业的基本构成\npublic interface ProcessingLogic {\n  public PartialResult process(Stream<DataElement> input);\n}\n\n//\npublic interface MergeLogic {\n  public Result merge(Collection<PartialResult> partialResults);\n}\n\npublic class BatchJob {\n  public final String dataSelector;\n  public final ProcessingLogic processingLogic;\n  public final MergeLogic mergeLogic;\n\n  public BatchJob(String dataSelector,\n                  ProcessingLogic processingLogic, MergeLogic mergeLogic) {\n    this.dataSelector = dataSelector;\n    this.processingLogic = processingLogic;\n    this.mergeLogic = mergeLogic;\n  }\n\n  public BatchJob withDataSelector(String selector) {\n    return new BatchJob(selector, processingLogic, mergeLogic);\n  }\n}\n代码清单 14-8 通过调用Nashorn JavaScript脚本引擎执行处理逻辑\npublic class PartSuccess implements PartialResult {\n  public final int value;\n\n  public PartSuccess(int value) {\n    this.value = value;\n  }\n\n  @Override\n  public String toString() {\n    return \"ResultSuccess(\" + value + \")\";\n  }\n}\n\npublic class PartFailure implements PartialResult {\n  public final Throwable failure;\n\n  public PartFailure(Throwable failure) {\n    this.failure = failure;\n  }\n\n  @Override\n  public String toString() {\n    return \"ResultFailure(\" + failure.getMessage() + \")\";\n  }\n}\n\npublic class BatchJobJS {\n  public final String dataSelector;\n  public final String processingLogic;\n  public final String mergeLogic;\n\n  public BatchJobJS(String dataSelector,\n                    String processingLogic, String mergeLogic) {\n    this.dataSelector = dataSelector;\n    this.processingLogic = processingLogic;\n    this.mergeLogic = mergeLogic;\n  }\n\n  public BatchJobJS withDataSelector(String selector) {\n    return new BatchJobJS(selector, processingLogic, mergeLogic);\n  }\n}\n\npublic class WorkerJS {\n  public PartialResult runJob(BatchJobJS job) {\n    ScriptEngine engine =\n      new ScriptEngineManager().getEngineByName(\"nashorn\");\n    Invocable invocable = (Invocable) engine;\n\n    try {\n      engine.eval(job.processingLogic);\n      final Stream<DataElement> input = provideData(job.dataSelector);\n      PartialResult result =\n        (PartialResult) invocable.invokeFunction(\"process\", input);\n      return result;\n    } catch (Exception e) {\n      return new PartFailure(e);\n    }\n  }\n\n  private Stream<DataElement> provideData(String selector) {\n    /* fetch data from persistent storage in streaming fashion */\n    return Stream.of(1, 2, 3).map(DataElement::new);\n  }\n}\njob.js\nvar PartSuccess = Java.type(\n    'chapter14.ComplexCommand.PartSuccess');\n\nvar process = function (input) {\n    // 'input' is a Java 8 Stream\n    var value = input.count();\n    return new PartSuccess(value);\n}\n代码清单 14-9 外部 DSL 使用了不同于宿主编程语言的语法\nFOREACH Car (_, _, year, price)\nSELECT year ? 1950 && year < 1960\nMEDIAN OF price\nREMEMBER AS p\n\nFOREACH Car (make, model, _, price)\nSELECT price > p\nDISTINCT VALUES OF (make, model)\nRETURN AS RESULT\n代码清单 14-10 内部 DSL\npublic static void akkaStreamDSL() {\n  RunnableGraph<CompletionStage<Long>> p =\n    Source.<DataElement>empty()\n      .filter(new InRange(\"year\", 1950, 1960))\n      .toMat(\n        Sink.fold(0L, new Median<Long>(\"price\")),\n        Keep.<NotUsed, CompletionStage<Long>>right());\n\n  Source.<DataElement>empty()\n    .map(new Inject<Long>(p, \"p\"))\n    .filter(new Filter(\"price > p\"))\n    .to(Sink.fold(\n      Collections.emptySet(),\n      new DistinctValues<Pair<String, String>>(\"make\", \"model\")));\n}","title":"14.3 复杂命令模式"},{"location":"/chapter-14/index.html#14-5-托管阻塞模式","text":"代码清单 14-11 维护一个私有的ExecutorService\npublic enum AccessRights {\n  READ_JOB_STATUS,\n  SUBMIT_JOB;\n\n  public static final AccessRights[] EMPTY = new AccessRights[] {};\n}\n\npublic class CheckAccess {\n  public final String username;\n  public final String credentials;\n  public final AccessRights[] rights;\n  public final ActorRef replyTo;\n\n  public CheckAccess(String username, String credentials,\n      AccessRights[] rights, ActorRef replyTo) {\n    this.username = username;\n    this.credentials = credentials;\n    this.rights = rights;\n    this.replyTo = replyTo;\n  }\n}\n\npublic class CheckAccessResult {\n  public final String username;\n  public final String credentials;\n  public final AccessRights[] rights;\n\n  public CheckAccessResult(CheckAccess ca, AccessRights[] rights) {\n    this.username = ca.username;\n    this.credentials = ca.credentials;\n    this.rights = rights;\n  }\n}\n\npublic class AccessService extends AbstractActor {\n  private final ExecutorService pool;\n  private final DataSource db;\n\n  public AccessService(DataSource db, int poolSize, int queueSize) {\n    this.db = db;\n    pool = new ThreadPoolExecutor(\n        0, poolSize,\n        60, SECONDS, new LinkedBlockingDeque<>(queueSize));\n  }\n\n  @Override\n  public Receive createReceive() {\n    final ActorRef self = self();\n    return ReceiveBuilder.create()\n      .match(CheckAccess.class, ca -> {\n        try {\n          pool.execute(() -> checkAccess(db, ca, self));\n        } catch (RejectedExecutionException e) {\n          ca.replyTo.tell(\n            new CheckAccessResult(ca, AccessRights.EMPTY), self);\n        }\n      })\n      .build();\n  }\n\n  @Override\n  public void postStop() {\n    pool.shutdownNow();\n  }\n\n  private static void checkAccess(DataSource db,\n      CheckAccess ca, ActorRef self) {\n    try (Connection conn = db.getConnection()) {\n      final ResultSet result =\n          conn.createStatement().executeQuery(\"<figure out access rights>\");\n      final List<AccessRights> rights = new LinkedList<>();\n      while (result.next()) {\n        rights.add(AccessRights.valueOf(result.getString(0)));\n      }\n      ca.replyTo.tell(\n          new CheckAccessResult(ca, rights.toArray(AccessRights.EMPTY)), self);\n    } catch (Exception e) {\n      ca.replyTo.tell(new CheckAccessResult(ca, AccessRights.EMPTY), self);\n    }\n  }\n}","title":"14.5 托管阻塞模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"在这一章中，我们将探讨一些存在于反应式组件之间最基本的通信模式：具体而言，我们将讨论消息是如何在它们之间流动的。在第10章中，我们讨论了理论背景，提到了系统中的通信路径设计对于系统的成功来说至关重要——无论是对现实世界的组织，还是反应式应用程序。","title":"第15章——消息流模式"},{"location":"/chapter-15/index.html#15-1-请求-响应模式","text":"代码清单15-1 服务器向发起请求的地址发送响应\npublic class Server {\n  static final int SERVER_PORT = 8888;\n\n  static public void main(String[] args) throws IOException {\n    // bind a socket for receiving packets\n    try (final DatagramSocket socket =\n        new DatagramSocket(SERVER_PORT)) {\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet1 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet1);\n\n      final SocketAddress sender = packet1.getSocketAddress();\n      System.out.println(\"server: received \" +\n          new String(packet1.getData()));\n      System.out.println(\"server: sender was \" + sender);\n\n      // send response back\n      final byte[] response = \"got it!\".getBytes();\n      final DatagramPacket packet2 =\n          new DatagramPacket(response, response.length, sender);\n      socket.send(packet2);\n    }\n  }\n}\n代码清单15-2 客户端发送一个请求，然后阻塞直到接收到服务器的响应\npublic class Client {\n  static public void main(String[] args) throws IOException {\n    // get local socket with random port\n    try (final DatagramSocket socket = new DatagramSocket()) {\n\n      // send message to server\n      final byte[] request = \"hello\".getBytes();\n      final SocketAddress serverAddress =\n          new InetSocketAddress(\"localhost\", SERVER_PORT);\n      final DatagramPacket packet1 =\n          new DatagramPacket(request, request.length, serverAddress);\n      socket.send(packet1);\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet2 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet2);\n\n      final SocketAddress sender = packet2.getSocketAddress();\n      System.out.println(\"client: received \" +\n          new String(packet2.getData()));\n      System.out.println(\"client: sender was \" + sender);\n    }\n  }\n}\nServer 的输出结果\nserver: received hello\nserver: sender was /127.0.0.1:55589\nClient 的可能输出结果\nclient: received got it!\nclient: sender was /127.0.0.1:8888\nHTTP Request Header\nGET /request?msg=hello HTTP/1.1\nHost: client-interface.our.application.domain\nAccept: application/json\nHTTP Response Header\nHTTP/1.1 200 OK\n...\nContent-Type: application/json\nContent-Length: 22\n{\"response\":\"got it!\"}\n代码清单15-3 使用Akka UntypedActor 来建模请求——响应模式\nobject RequestResponseActors {\n\n  case class Request(msg: String)\n\n  case class Response(msg: String)\n\n  class Responder extends Actor {\n    def receive: Receive = {\n      case Request(msg) ⇒\n        println(s\"got request: $msg\")\n        sender() ! Response(\"got it!\")\n    }\n  }\n\n  class Requester(responder: ActorRef) extends Actor {\n    responder ! Request(\"hello\")\n\n    def receive: Receive = {\n      case Response(msg) ⇒\n        println(s\"got response: $msg\")\n        context.system.terminate()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sys = ActorSystem(\"ReqRes\")\n    val responder = sys.actorOf(Props[Responder], \"responder\")\n    val requester = sys.actorOf(Props(new Requester(responder)), \"requester\")\n  }\n\n}\n运行结果\ngot request: hello\ngot response: got it!\n代码清单15-4 在请求消息中显式地包含响应地址\nobject RequestResponseTypedActors {\n\n  case class Request(msg: String, replyTo: ActorRef[Response])\n\n  case class Response(msg: String)\n\n  val responder: Behavior[Request] =\n    Static {\n      case Request(msg, replyTo) ⇒\n        println(s\"got request: $msg\")\n        replyTo ! Response(\"got it!\")\n    }\n\n  def requester(responder: ActorRef[Request]): Behavior[Response] =\n    SelfAware { self ⇒\n      responder ! Request(\"hello\", self)\n      Total {\n        case Response(msg) ⇒\n          println(s\"got response: $msg\")\n          Stopped\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(\"ReqResTyped\", ContextAware[Unit] { ctx ⇒\n      val res = ctx.spawn(responder, \"responder\")\n      val req = ctx.watch(ctx.spawn(requester(res), \"requester\"))\n      Full {\n        case Sig(_, Terminated(`req`)) ⇒ Stopped\n      }\n    })\n  }\n}\n代码清单15-5 基于单向消息传递的请求——响应模式\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function (err, conn) {\n    conn.createChannel(function (err, ch) {\n        var q = 'rpc_queue';\n        ch.assertQueue(q, {durable: false});\n        ch.prefetch(1);\n        ch.consume(q, function reply(msg) {\n            console.log(\"got request: %s\", msg.content.toString());\n            ch.sendToQueue(msg.properties.replyTo,\n                new Buffer('got it!'),\n                {correlationId: msg.properties.correlationId});\n            ch.ack(msg);\n        });\n    });\n});\n代码清单15-6 监听与原始请求具有相同的关联ID的响应\nvar uuid = require('node-uuid');\namqp.connect('amqp://localhost', function (err, conn) {\n    conn.createChannel(function (err, ch) {\n        ch.assertQueue('responses', {}, function (err, q) {\n            var corr = uuid.v1();\n            ch.consume(q.queue, function (msg) {\n                if (msg.properties.correlationId === corr) {\n                    console.log('got response: %s', msg.content.toString());\n                    setTimeout(function () {\n                        conn.close();\n                        process.exit(0)\n                    }, 500);\n                }\n            }, {noAck: true});\n            ch.sendToQueue('rpc_queue',\n                new Buffer('hello'),\n                {correlationId: corr, replyTo: q.queue});\n        });\n    });\n});","title":"15.1 请求——响应模式"},{"location":"/chapter-15/index.html#15-2-消息自包含模式","text":"SMTP\nS: 220 mailhost.example.com ESMTP Postfix\nC: HELO alice-workstation.example.com\nS: 250 Hello alice-workstation.example.com\nC: MAIL FROM:<alice@example.com>\nS: 250 Ok\nC: RCPT TO:<bob@example.com>\nS: 250 Ok\nC: DATA\nS: 354 End data with <CR><LF>.<CR><LF>\nC: From: \"Alice\" <alice@example.com>\nC: To: \"Bob\" <bob@example.com>\nC: Date: Fri, 23 October 2015 10:34:12 +0200\nC: Subject: lunch\nC:\nC: Hi Bob,\nC:\nC: sorry, I cannot make it, something else came up.\nC:\nC: Regards, Alice\nC: .\nS: 250 Ok, queued as 4567876345\nC: QUIT\nS: 221 Bye\n代码清单15-7 封装了多次 SMTP 交换所需要的信息\ncase class SendEmail(\n  sender:     String,\n  recipients: List[String],\n  body:       String, correlationID: UUID,\n  replyTo: ActorRef[SendEmailResult])\ncase class SendEmailResult(\n  correlationID: UUID,\n  status:        StatusCode,\n  explanation:   Option[String]) extends Result\n代码清单15-8 分离电子邮件主体，使得其可以按需投递\ncase class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])(body: Source[String]) extends StreamedRequest {\n  override def payload: Source[String] = body\n}\n代码清单15-9 允许邮件主体可以被接收者拉取\ncase class SendEmail(sender: String, recipients: List[String],\n                     bodyLocation:  URL,\n                     correlationID: UUID,\n                     replyTo:       ActorRef[SendEmailResult])","title":"15.2 消息自包含模式"},{"location":"/chapter-15/index.html#15-3-询问模式","text":"代码清单15-10 请求启动验证过程的简单协议\ncase class StartVerificationProcess(userEmail: String, replyTo: ActorRef[VerificationProcessResponse]) extends MyCommands\n\nsealed trait VerificationProcessResponse\n\ncase class VerificationProcessStarted(userEmail: String) extends VerificationProcessResponse\n\ncase class VerificationProcessFailed(userEmail: String) extends VerificationProcessResponse\n代码清单15-11 一个转发结果的匿名子Actor\ndef withChildActor(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx: ActorContext[StartVerificationProcess] ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val childActor = ctx.spawnAnonymous(FullTotal[Result] {\n          case Sig(ctx, PreStart) ⇒\n            ctx.setReceiveTimeout(5.seconds, ReceiveTimeout)\n            Same\n          case Msg(_, ReceiveTimeout) ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.OK, _)) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            replyTo ! VerificationProcessStarted(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.Failed, explanation)) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(wrongID, _, _)) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            Same\n        })\n        val request = SendEmail(\n          \"verification@example.com\",\n          List(userEmail),\n          constructBody(userEmail, corrID), corrID, childActor)\n        emailGateway ! request\n    }\n  }\n代码清单15-12 由询问模式所产生的Future，并进行了转换\ndef withAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    implicit val timeout: Timeout = Timeout(5.seconds)\n    import ctx.executionContext\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val response: Future[SendEmailResult] =\n          emailGateway ? (SendEmail(\n            \"verification@example.com\",\n            List(userEmail),\n            constructBody(userEmail, corrID), corrID, _))\n        response.map {\n          case SendEmailResult(`corrID`, StatusCode.OK, _) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            VerificationProcessStarted(userEmail)\n          case SendEmailResult(`corrID`, StatusCode.Failed, explanation) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            VerificationProcessFailed(userEmail)\n          case SendEmailResult(wrongID, _, _) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            VerificationProcessFailed(userEmail)\n        }.recover {\n          case _: AskTimeoutException ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            VerificationProcessFailed(userEmail)\n        }.foreach(result ⇒ replyTo ! result)\n    }\n  }\n代码清单15-13 不使用内置支持实现询问模式\ndef withoutAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware[MyCommands] { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    var statusMap = Map.empty[UUID, (String, ActorRef[VerificationProcessResponse])]\n    val adapter = ctx.spawnAdapter((s: SendEmailResult) ⇒\n      MyEmailResult(s.correlationID, s.status, s.explanation))\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val request = SendEmail(\n          \"verification@example.com\",\n          List(userEmail),\n          constructBody(userEmail, corrID), corrID, adapter)\n        emailGateway ! request\n        statusMap += corrID -> (userEmail, replyTo)\n        ctx.schedule(5.seconds, ctx.self,\n          MyEmailResult(corrID, StatusCode.Failed, Some(\"timeout\")))\n      case MyEmailResult(corrID, status, expl) ⇒\n        statusMap.get(corrID) match {\n          case None ⇒\n            log.error(\n              \"received SendEmailResult for unknown correlation ID {}\",\n              corrID)\n          case Some((userEmail, replyTo)) ⇒\n            status match {\n              case StatusCode.OK ⇒\n                log.debug(\n                  \"successfully started the verification process for {}\",\n                  userEmail)\n                replyTo ! VerificationProcessStarted(userEmail)\n              case StatusCode.Failed ⇒\n                log.info(\n                  \"failed to start the verification process for {}: {}\",\n                  userEmail, expl)\n                replyTo ! VerificationProcessFailed(userEmail)\n            }\n            statusMap -= corrID\n        }\n    }\n  }.narrow[StartVerificationProcess]","title":"15.3 询问模式"},{"location":"/chapter-15/index.html#15-5-聚合器模式","text":"代码清单15-14 使用for推导式来聚合三个Future表达式的结果。\ndef futureFrontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    import ctx.executionContext\n    implicit val timeout: Timeout = Timeout(1.second)\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val cssFuture =\n          (themes ? (GetTheme(user, _: ActorRef[ThemeResult])))\n            .map(_.css)\n            .recover {\n              case _: AskTimeoutException ⇒ \"default.css\"\n            }\n        val personalNewsFuture =\n          (personalNews ? (GetPersonalNews(\n            user,\n            _: ActorRef[PersonalNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        val topNewsFuture =\n          (topNews ? (GetTopNews(_: ActorRef[TopNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        for {\n          css ← cssFuture\n          personalNews ← personalNewsFuture\n          topNews ← topNewsFuture\n        } {\n          val topSet = topNews.toSet\n          val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n          replyTo ! FrontPageResult(user, css, allNews)\n        }\n    }\n  }\n代码清单15-15 使用子Actor替代Future组合子的使用\nprivate def pf(p: PartialFunction[AnyRef, Unit]): p.type = p\n\ndef frontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val childRef = ctx.spawnAnonymous(Deferred { () ⇒\n          val builder = new FrontPageResultBuilder(user)\n          Partial[AnyRef](\n            pf {\n              case ThemeResult(css)         ⇒ builder.addCSS(css)\n              case PersonalNewsResult(news) ⇒ builder.addPersonalNews(news)\n              case TopNewsResult(news)      ⇒ builder.addTopNews(news)\n              case ReceiveTimeout           ⇒ builder.timeout()\n            } andThen { _ ⇒\n              if (builder.isComplete) {\n                replyTo ! builder.result\n                Stopped\n              } else Same\n            })\n        })\n        themes ! GetTheme(user, childRef)\n        personalNews ! GetPersonalNews(user, childRef)\n        topNews ! GetTopNews(childRef)\n        ctx.schedule(1.second, childRef, ReceiveTimeout)\n    }\n  }\n代码清单15-16 使用一个构建器来更加直接地表达领域模型\nclass FrontPageResultBuilder(user: String) {\n  private var css: Option[String] = None\n  private var personalNews: Option[List[String]] = None\n  private var topNews: Option[List[String]] = None\n\n  def addCSS(css: String): Unit = this.css = Option(css)\n\n  def addPersonalNews(news: List[String]): Unit =\n    this.personalNews = Option(news)\n\n  def addTopNews(news: List[String]): Unit =\n    this.topNews = Option(news)\n\n  def timeout(): Unit = {\n    if (css.isEmpty) css = Some(\"default.css\")\n    if (personalNews.isEmpty) personalNews = Some(Nil)\n    if (topNews.isEmpty) topNews = Some(Nil)\n  }\n\n  def isComplete: Boolean = css.isDefined &&\n    personalNews.isDefined && topNews.isDefined\n\n  def result: FrontPageResult = {\n    val topSet = topNews.get.toSet\n    val allNews = topNews.get :::\n      personalNews.get.filterNot(topSet.contains)\n    FrontPageResult(user, css.get, allNews)\n  }\n}\n代码清单15-17 添加第4个服务，降低了代码的可读性\nval overrideFuture =\n  (overrides ? (GetOverride(_: ActorRef[OverrideResult])))\n    .recover {\n      case _: AskTimeoutException ⇒ NoOverride\n    }\nfor {\n  css ← cssFuture\n  personalNews ← personalNewsFuture\n  topNews ← topNewsFuture\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒\n    val topSet = topNews.toSet\n    val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n    replyTo ! FrontPageResult(user, css, allNews)\n  case other ⇒ // nothing to do here\n}\nfor {\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒ // nothing to do here\n  case Override(css, news) ⇒\n    replyTo ! FrontPageResult(user, css, news)\n}","title":"15.5 聚合器模式"},{"location":"/chapter-15/index.html#15-7-业务握手协议-又名可靠投递模式-","text":"代码清单15-18 使用Actor实现上面的（信息）交换\ncase class ChangeBudget(amount: BigDecimal, replyTo: ActorRef)\n\ncase object ChangeBudgetDone\n\ncase class CannotChangeBudget(reason: String)\n\nclass Sam(\n  alice:  ActorRef,\n  bob:    ActorRef,\n  amount: BigDecimal) extends Actor {\n  def receive: Receive = talkToAlice()\n\n  def talkToAlice(): Receive = {\n    alice ! ChangeBudget(-amount, self)\n    context.setReceiveTimeout(1.second)\n\n    LoggingReceive {\n      case ChangeBudgetDone           ⇒ context.become(talkToBob())\n      case CannotChangeBudget(reason) ⇒ context.stop(self)\n      case ReceiveTimeout             ⇒ alice ! ChangeBudget(-amount, self)\n    }\n  }\n\n  def talkToBob(): Receive = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n}\n\nclass Alice extends Actor {\n  var budget: BigDecimal = 10\n  var alreadyDone: Set[ActorRef] = Set.empty\n\n  def receive = LoggingReceive {\n    case ChangeBudget(amount, replyTo) if alreadyDone(replyTo) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo) if amount + budget > 0 ⇒\n      budget += amount\n      alreadyDone += replyTo\n      context.watch(replyTo)\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(_, replyTo) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case Terminated(saga) ⇒\n      alreadyDone -= saga\n  }\n}\n代码清单15-19 向预算消息添加持久性\ncase class AliceConfirmedChange(deliveryId: Long)\n\ncase class AliceDeniedChange(deliveryId: Long)\n\nclass PersistentSam(\n  alice:                      ActorPath,\n  bob:                        ActorPath,\n  amount:                     BigDecimal,\n  override val persistenceId: String)\n  extends PersistentActor with AtLeastOnceDelivery with ActorLogging {\n\n  def receiveCommand: Actor.emptyBehavior.type = Actor.emptyBehavior\n\n  override def preStart(): Unit = {\n    context.become(talkToAlice())\n  }\n\n  def talkToAlice(): Receive = {\n    log.debug(\"talking to Alice\")\n    var deliveryId: Long = 0\n    deliver(alice)(id ⇒ {\n      deliveryId = id;\n      ChangeBudget(-amount, self, persistenceId)\n    })\n\n    LoggingReceive({\n      case ChangeBudgetDone ⇒\n        persist(AliceConfirmedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.become(talkToBob())\n        }\n      case CannotChangeBudget(reason) ⇒\n        persist(AliceDeniedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.stop(self)\n        }\n    }: Receive)\n  }\n\n  def talkToBob(): Actor.emptyBehavior.type = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n\n  def receiveRecover = LoggingReceive {\n    case AliceConfirmedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.become(talkToBob())\n    case AliceDeniedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.stop(self)\n  }\n}\n代码清单15-20 Alice Actor的持久化版本\ncase class BudgetChanged(amount: BigDecimal, persistenceId: String)\n\ncase object CleanupDoneList\n\ncase class ChangeDone(persistenceId: String)\n\nclass PersistentAlice extends PersistentActor with ActorLogging {\n  def persistenceId: String = \"Alice\"\n\n  implicit val mat: ActorMaterializer = ActorMaterializer()\n\n  import context.dispatcher\n\n  var alreadyDone: Set[String] = Set.empty\n  var budget: BigDecimal = 10\n\n  val cleanupTimer: Cancellable = context.system.scheduler.\n    schedule(1.hour, 1.hour, self, CleanupDoneList)\n\n  def receiveCommand = LoggingReceive {\n    case ChangeBudget(amount, replyTo, id) if alreadyDone(id) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo, id) if amount + budget > 0 ⇒\n      persist(BudgetChanged(amount, id)) { ev ⇒\n        budget += ev.amount\n        alreadyDone += ev.persistenceId\n        replyTo ! ChangeBudgetDone\n      }\n    case ChangeBudget(_, replyTo, _) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case CleanupDoneList ⇒\n      val journal = PersistenceQuery(context.system)\n        .readJournalFor[LeveldbReadJournal](LeveldbReadJournal.Identifier)\n      for (persistenceId ← alreadyDone) {\n        val stream = journal\n          .currentEventsByPersistenceId(persistenceId)\n          .map(_.event)\n          .collect {\n            case AliceConfirmedChange(_) ⇒ ChangeDone(persistenceId)\n          }\n        stream.runWith(Sink.head).pipeTo(self)\n      }\n    case ChangeDone(id) ⇒\n      persist(ChangeDone(id)) { ev ⇒\n        alreadyDone -= ev.persistenceId\n      }\n  }\n\n  def receiveRecover = LoggingReceive {\n    case BudgetChanged(amount, id) ⇒\n      budget += amount\n      alreadyDone += id\n    case ChangeDone(id) ⇒\n      alreadyDone -= id\n  }\n\n  override def postStop(): Unit = {\n    cleanupTimer.cancel()\n  }\n}","title":"15.7 业务握手协议（又名可靠投递模式）"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"在前面的章节里，你学会了如何将系统拆分成较小的部分，以及这些部分之间如何通信以解决较大的任务。有一个我们到目前为止尚未提及的角度：除了确定谁与谁交互之外，你必须同样考虑通信的时效性。为了让你的系统在不同的负载下都更具有回弹性，你需要能够阻止组件因为过量的请求速率而不可控制地失败的机制。为此，这一章介绍了下面四种基本模式。","title":"第16章——流控制模式"},{"location":"/chapter-16/index.html#16-1-拉取模式","text":"代码清单16-1 在拉取输入的工作者内部处理昂贵的计算\nclass Worker(manager: ActorRef) extends Actor {\n  val mc = new MathContext(100, RoundingMode.HALF_EVEN)\n  val plus = BigDecimal(1, mc)\n  val minus = BigDecimal(-1, mc)\n\n  var requested = 0\n\n  def request(): Unit =\n    if (requested < 5) {\n      manager ! WorkRequest(self, 10)\n      requested += 10\n    }\n\n  request()\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Job(id, data, replyTo) ⇒\n      requested -= 1\n      request()\n      val sign = if ((data & 1) == 1) plus else minus\n      val result = sign / data\n      replyTo ! JobResult(id, result)\n  }\n}\n代码清单16-2 按工作者所请求的数目给它们提供任务\nclass Manager extends Actor {\n\n  val workStream: Iterator[Job] =\n    Iterator from 1 map (x ⇒ Job(x, x, self)) take 1000000\n\n  val aggregator: (BigDecimal, BigDecimal) ⇒ BigDecimal = (x: BigDecimal, y: BigDecimal) ⇒ x + y\n  var approximation = BigDecimal(0, new MathContext(10000, RoundingMode.HALF_EVEN))\n\n  var outstandingWork = 0\n\n  (1 to 8) foreach (_ ⇒ context.actorOf(Props(new Worker(self))))\n\n  def receive: PartialFunction[Any, Unit] = {\n    case WorkRequest(worker, items) ⇒\n      workStream.take(items).foreach {\n        job ⇒\n          worker ! job\n          outstandingWork += 1\n      }\n    case JobResult(id, report) ⇒\n      approximation = aggregator(approximation, report)\n      outstandingWork -= 1\n      if (outstandingWork == 0 && workStream.isEmpty) {\n        println(\"final result: \" + approximation)\n        context.system.terminate()\n      }\n  }\n}","title":"16.1 拉取模式"},{"location":"/chapter-16/index.html#16-2-托管队列模式","text":"代码清单16-3 管理一个工作队列以对过载作出反应\nclass Manager extends Actor {\n\n  var workQueue: Queue[Job] = Queue.empty[Job]\n  var requestQueue: Queue[WorkRequest] = Queue.empty[WorkRequest]\n\n  (1 to 8) foreach (_ ⇒ context.actorOf(Props(new Worker(self))))\n\n  def receive: PartialFunction[Any, Unit] = {\n    case job @ Job(id, _, replyTo) ⇒\n      if (requestQueue.isEmpty) {\n        if (workQueue.size < 1000) workQueue :+= job\n        else replyTo ! JobRejected(id)\n      } else {\n        val WorkRequest(worker, items) = requestQueue.head\n        worker ! job\n        if (items > 1) worker ! DummyWork(items - 1)\n        requestQueue = requestQueue.drop(1)\n      }\n    case wr @ WorkRequest(worker, items) ⇒\n      if (workQueue.isEmpty) {\n        if (!requestQueue.contains(worker)) requestQueue :+= wr\n      } else {\n        workQueue.iterator.take(items).foreach(job ⇒ worker ! job)\n        if (workQueue.size < items) worker ! DummyWork(items - workQueue.size)\n        workQueue = workQueue.drop(items)\n      }\n  }\n}\nQueuePattern.scala\nclass Manager extends Actor {\n\n  var workQueue: Queue[Job] = Queue.empty[Job]\n  var requestQueue: Queue[WorkRequest] = Queue.empty[WorkRequest]\n\n  (1 to 8) foreach (_ ⇒ context.actorOf(Props(new Worker(self))))\n\n  def receive: PartialFunction[Any, Unit] = {\n    case job @ Job(id, _, replyTo) ⇒\n      if (requestQueue.isEmpty) {\n        if (workQueue.size < 1000) workQueue :+= job\n        else replyTo ! JobRejected(id)\n      } else {\n        val WorkRequest(worker, items) = requestQueue.head\n        worker ! job\n        if (items > 1) worker ! DummyWork(items - 1)\n        requestQueue = requestQueue.drop(1)\n      }\n    case wr @ WorkRequest(worker, items) ⇒\n      if (workQueue.isEmpty) {\n        if (!requestQueue.contains(worker)) requestQueue :+= wr\n      } else {\n        workQueue.iterator.take(items).foreach(job ⇒ worker ! job)\n        if (workQueue.size < items) worker ! DummyWork(items - workQueue.size)\n        workQueue = workQueue.drop(items)\n      }\n  }\n}","title":"16.2 托管队列模式"},{"location":"/chapter-16/index.html#16-3-丢弃模式","text":"DropPattern.scala\nval queueThreshold = 1000\nval dropThreshold = 1500\n\ndef random: ThreadLocalRandom = ThreadLocalRandom.current\n\ndef shallEnqueue(atSize: Int): Boolean =\n  (atSize < queueThreshold) || {\n    val dropFactor = (atSize - queueThreshold) >> 6\n    random.nextInt(dropFactor + 2) == 0\n  }\nDropPattern.scala\ncase job @ Job(id, _, replyTo) ⇒\n  if (requestQueue.isEmpty) {\n    val atSize = workQueue.size\n    if (shallEnqueue(atSize)) workQueue :+= job\n    else if (atSize < dropThreshold) replyTo ! JobRejected(id)\n  } else {\nDropPatternWithProtection.scala\nprivate case class WorkEnvelope(job: Job) {\n  @volatile var consumed = false\n}\n\nprivate class IncomingQueue(manager: ActorRef) extends Actor {\n  var workQueue: Queue[WorkEnvelope] = Queue.empty[WorkEnvelope]\n\n  def receive: PartialFunction[Any, Unit] = {\n    case job: Job ⇒\n      workQueue = workQueue.dropWhile(_.consumed)\n      if (workQueue.size < 1000) {\n        val envelope = WorkEnvelope(job)\n        workQueue :+= envelope\n        manager ! envelope\n      }\n  }\n}","title":"16.3 丢弃模式"},{"location":"/chapter-16/index.html#16-4-限流模式","text":"代码清单16-4 根据特定速率使用令牌桶来拉取工作\nclass CalculatorClient(\n  workSource:    ActorRef,\n  calculator:    ActorRef,\n  ratePerSecond: Long,\n  bucketSize:    Int,\n  batchSize:     Int) extends Actor {\n  def now(): Long = System.nanoTime()\n\n  val nanoSecondsBetweenTokens: Long = 1000000000L / ratePerSecond\n\n  var tokenBucket: Int = bucketSize\n  var lastTokenTime: Long = now()\n\n  def refillBucket(time: Long): Unit = {\n    val accrued = (time - lastTokenTime) * ratePerSecond / 1000000000L\n    if (tokenBucket + accrued >= bucketSize) {\n      tokenBucket = bucketSize\n      lastTokenTime = time\n    } else {\n      tokenBucket += accrued.toInt\n      lastTokenTime += accrued * nanoSecondsBetweenTokens\n    }\n  }\n\n  def consumeToken(time: Long): Unit = {\n    refillBucket(time)\n    tokenBucket -= 1\n  }\n\n  var requested = 0\n\n  def request(time: Long): Unit =\n    if (tokenBucket - requested >= batchSize) {\n      sendRequest(time, batchSize)\n    } else if (requested == 0) {\n      if (tokenBucket > 0) {\n        sendRequest(time, tokenBucket)\n      } else {\n        val timeForNextToken = lastTokenTime + nanoSecondsBetweenTokens - time\n        context.system.scheduler\n          .scheduleOnce(\n            timeForNextToken.nanos,\n            workSource,\n            WorkRequest(self, 1))(context.dispatcher)\n        requested = 1\n        if (Debug)\n          println(s\"$time: request(1) scheduled for ${time + timeForNextToken}\")\n      }\n    } else if (Debug)\n      println(s\"$time: not requesting (requested=$requested tokenBucket=$tokenBucket)\")\n\n  def sendRequest(time: Long, items: Int): Unit = {\n    if (Debug)\n      println(s\"$time: requesting $items items (requested=$requested tokenBucket=$tokenBucket)\")\n    workSource ! WorkRequest(self, items)\n    requested += items\n  }\n\n  request(lastTokenTime)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case job: Job ⇒\n      val time = now()\n      if (Debug) if (requested == 1) println(s\"$time: received job\")\n      consumeToken(time)\n      requested -= 1\n      request(time)\n      calculator ! job\n  }\n}","title":"16.4 限流模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"前一章介绍了消息速率、负载和时间的各种概念；我们之前只考虑了不同组件之间和时间无关的关联。这一章增加了另一个正交维度来完成这整个版图：维持状态几乎是所有组件的共同目的，而我们还没有讨论应该怎么做到这一点。这里所呈现的模式彼此密切相关，并形成了一个有机整体。","title":"第17章——状态管理和持久化模式"},{"location":"/chapter-17/index.html#17-1-领域对象模式","text":"DomainObject.scala\ncase class ItemRef(id: URI)\n\ncase class CustomerRef(id: URI)\n\ncase class ShoppingCartRef(id: URI)\n清单 17-1 一个最小化的购物车定义\ncase class ShoppingCart(items: Map[ItemRef, Int], owner: Option[CustomerRef]) {\n  def setOwner(customer: CustomerRef): ShoppingCart = {\n    require(owner.isEmpty, \"owner cannot be overwritten\")\n    copy(owner = Some(customer))\n  }\n\n  def addItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(count > 0, s\"count must be positive (trying to add $item with count $count)\")\n    val currentCount = items.get(item).getOrElse(0)\n    copy(items = items.updated(item, currentCount + count))\n  }\n\n  def removeItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(count > 0, s\"count must be positive (trying to remove $item with count $count)\")\n    val currentCount = items.get(item).getOrElse(0)\n    val newCount = currentCount - count\n    if (newCount <= 0) copy(items = items - item)\n    else copy(items = items.updated(item, newCount))\n  }\n\n  // 代码清单 17-6\n  def applyEvent(event: Event): ShoppingCart = event match {\n    case OwnerChanged(_, owner)      ⇒ setOwner(owner)\n    case ItemAdded(_, item, count)   ⇒ addItem(item, count)\n    case ItemRemoved(_, item, count) ⇒ removeItem(item, count)\n  }\n\n  // 代码清单 17-6\n}\n\nobject ShoppingCart {\n  val empty = ShoppingCart(Map.empty, None)\n}\n清单 17-2 用于和购物车对象通信的消息\ntrait ShoppingCartMessage {\n  def shoppingCart: ShoppingCartRef\n}\n\nsealed trait Command extends ShoppingCartMessage\n\ncase class SetOwner(\n  shoppingCart: ShoppingCartRef,\n  owner:        CustomerRef) extends Command\n\ncase class AddItem(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Command\n\ncase class RemoveItem(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Command\n\nsealed trait Query extends ShoppingCartMessage\n\ncase class GetItems(shoppingCart: ShoppingCartRef) extends Query\n\nsealed trait Event extends ShoppingCartMessage\n\ncase class OwnerChanged(\n  shoppingCart: ShoppingCartRef,\n  owner:        CustomerRef) extends Event\n\ncase class ItemAdded(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Event\n\ncase class ItemRemoved(\n  shoppingCart: ShoppingCartRef,\n  item:         ItemRef,\n  count:        Int) extends Event\n\nsealed trait Result extends ShoppingCartMessage\n\ncase class GetItemsResult(\n  shoppingCart: ShoppingCartRef,\n  items:        Map[ItemRef, Int]) extends Result\n清单 17-3 一个购物车管理者 Actor\ncase class ManagerCommand(cmd: Command, id: Long, replyTo: ActorRef)\n\ncase class ManagerEvent(id: Long, event: Event)\n\ncase class ManagerQuery(cmd: Query, id: Long, replyTo: ActorRef)\n\ncase class ManagerResult(id: Long, result: Result)\n\ncase class ManagerRejection(id: Long, reason: String)\n\nclass Manager(var shoppingCart: ShoppingCart) extends Actor {\n  /*\n   * this is the usual constructor, the above allows priming with\n   * previously persisted state.\n   */\n  def this() = this(ShoppingCart.empty)\n\n  def receive: PartialFunction[Any, Unit] = {\n    case ManagerCommand(cmd, id, replyTo) ⇒\n      try {\n        val event = cmd match {\n          case SetOwner(cart, owner) ⇒\n            shoppingCart = shoppingCart.setOwner(owner)\n            OwnerChanged(cart, owner)\n          case AddItem(cart, item, count) ⇒\n            shoppingCart = shoppingCart.addItem(item, count)\n            ItemAdded(cart, item, count)\n          case RemoveItem(cart, item, count) ⇒\n            shoppingCart = shoppingCart.removeItem(item, count)\n            ItemRemoved(cart, item, count)\n        }\n        replyTo ! ManagerEvent(id, event)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n    case ManagerQuery(cmd, id, replyTo) ⇒\n      try {\n        val result = cmd match {\n          case GetItems(cart) ⇒\n            GetItemsResult(cart, shoppingCart.items)\n        }\n        replyTo ! ManagerResult(id, result)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n  }\n}","title":"17.1 领域对象模式"},{"location":"/chapter-17/index.html#17-2-分片模式","text":"清单 17-4 为购物车定义分片算法\nobject ShardSupport {\n  /*\n   * use the shoppingCart reference as the sharding key; the partial function\n   * must return both the key and the message to be forwarded, and if it does\n   * not match then the message is dropped\n   */\n  val extractEntityId: ShardRegion.ExtractEntityId = {\n    case mc @ ManagerCommand(cmd, _, _) ⇒ cmd.shoppingCart.id.toString -> mc\n    case mc @ ManagerQuery(query, _, _) ⇒ query.shoppingCart.id.toString -> mc\n  }\n\n  /*\n   * allocate shoppingCarts into 256 shards based on the low 8 bits of their\n   * ID’s hash; this is a total function that must be defined for all messages\n   * that are forwarded\n   */\n  val extractShardId: ShardRegion.ExtractShardId = {\n    case ManagerCommand(cmd, _, _) ⇒ toHex(cmd.shoppingCart.id.hashCode & 255)\n    case ManagerQuery(query, _, _) ⇒ toHex(query.shoppingCart.id.hashCode & 255)\n  }\n\n  private def toHex(b: Int) =\n    new java.lang.StringBuilder(2)\n      .append(hexDigits(b >> 4))\n      .append(hexDigits(b & 15))\n      .toString\n\n  private val hexDigits = \"0123456789ABCDEF\"\n\n  val RegionName = \"ShoppingCart\"\n}\n清单 17-5 启动一个群集来托管分片\nval sys1 = ActorSystem(\"ShardingExample\", node1Config.withFallback(clusterConfig))\nval seed = Cluster(sys1).selfAddress\n\ndef startNode(sys: ActorSystem): Unit = {\n  Cluster(sys).join(seed)\n  ClusterSharding(sys).start(\n    typeName = ShardSupport.RegionName,\n    entityProps = Props(new Manager),\n    settings = ClusterShardingSettings(sys1),\n    extractEntityId = ShardSupport.extractEntityId,\n    extractShardId = ShardSupport.extractShardId)\n}\n\nstartNode(sys1)\n\nval sys2 = ActorSystem(\"ShardingExample\", clusterConfig)\nstartNode(sys2)\nSharding.scala\nval manager = ClusterSharding(sys1).shardRegion(ShardSupport.RegionName)","title":"17.2 分片模式"},{"location":"/chapter-17/index.html#17-3-事件溯源模式","text":"清单 17-6 将领域事件添加到业务逻辑\ncase class ShoppingCart(items: Map[ItemRef, Int], owner: Option[CustomerRef]) {\n  def setOwner(customer: CustomerRef): ShoppingCart = {\n    require(owner.isEmpty, \"owner cannot be overwritten\")\n    copy(owner = Some(customer))\n  }\n\n  def addItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(count > 0, s\"count must be positive (trying to add $item with count $count)\")\n    val currentCount = items.get(item).getOrElse(0)\n    copy(items = items.updated(item, currentCount + count))\n  }\n\n  def removeItem(item: ItemRef, count: Int): ShoppingCart = {\n    require(count > 0, s\"count must be positive (trying to remove $item with count $count)\")\n    val currentCount = items.get(item).getOrElse(0)\n    val newCount = currentCount - count\n    if (newCount <= 0) copy(items = items - item)\n    else copy(items = items.updated(item, newCount))\n  }\n\n  // 代码清单 17-6\n  def applyEvent(event: Event): ShoppingCart = event match {\n    case OwnerChanged(_, owner)      ⇒ setOwner(owner)\n    case ItemAdded(_, item, count)   ⇒ addItem(item, count)\n    case ItemRemoved(_, item, count) ⇒ removeItem(item, count)\n  }\n\n  // 代码清单 17-6\n}\n\nobject ShoppingCart {\n  val empty = ShoppingCart(Map.empty, None)\n}\n清单 17-7 持久化一个事件溯源领域对象\nclass PersistentObjectManager extends PersistentActor {\n  // we expect the name to be the shopping card ID\n  override def persistenceId: String = context.self.path.name\n\n  var shoppingCart: ShoppingCart = ShoppingCart.empty\n\n  def receiveCommand: PartialFunction[Any, Unit] = {\n    case ManagerCommand(cmd, id, replyTo) ⇒\n      try {\n        val event = cmd match {\n          case SetOwner(cart, owner)         ⇒ OwnerChanged(cart, owner)\n          case AddItem(cart, item, count)    ⇒ ItemAdded(cart, item, count)\n          case RemoveItem(cart, item, count) ⇒ ItemRemoved(cart, item, count)\n        }\n        // perform the update here in order to treat validation errors immediately\n        shoppingCart = shoppingCart.applyEvent(event)\n        persist(event) { _ ⇒\n          replyTo ! ManagerEvent(id, event)\n        }\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n    case ManagerQuery(cmd, id, replyTo) ⇒\n      try {\n        val result = cmd match {\n          case GetItems(cart) ⇒ GetItemsResult(cart, shoppingCart.items)\n        }\n        replyTo ! ManagerResult(id, result)\n      } catch {\n        case ex: IllegalArgumentException ⇒\n          replyTo ! ManagerRejection(id, ex.getMessage)\n      }\n  }\n\n  def receiveRecover: PartialFunction[Any, Unit] = {\n    case e: Event ⇒ shoppingCart = shoppingCart.applyEvent(e)\n  }\n}","title":"17.3 事件溯源模式"},{"location":"/chapter-17/index.html#17-4-事件流模式","text":"清单 17-8 在写日志期间对事件打标签\nclass ShoppingCartTagging(system: ExtendedActorSystem) extends WriteEventAdapter {\n  def manifest(event: Any): String = \"\"\n\n  def toJournal(event: Any): Any =\n    event match {\n      case s: ShoppingCartMessage ⇒ Tagged(event, Set(\"shoppingCart\"))\n      case other                  ⇒ other\n    }\n}\n清单 17-9 一个正在监听事件流的 Actor\nobject TopProductListener {\n\n  private class IntHolder(var value: Int)\n\n}\n\nclass TopProductListener extends Actor with ActorLogging {\n\n  import TopProductListener._\n\n  implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n  val readJournal: LeveldbReadJournal =\n    PersistenceQuery(context.system)\n      .readJournalFor[LeveldbReadJournal](LeveldbReadJournal.Identifier)\n\n  readJournal.eventsByTag(\"shoppingCart\", 0)\n    .collect { case EventEnvelope(_, _, _, add: ItemAdded) ⇒ add }\n    .groupedWithin(100000, 1.second)\n    .addAttributes(Attributes.asyncBoundary)\n    .runForeach { seq: Seq[ItemAdded] ⇒\n      val histogram = seq.foldLeft(Map.empty[ItemRef, IntHolder]) {\n        (map, event) ⇒\n          map.get(event.item) match {\n            case Some(holder) ⇒ {\n              holder.value += event.count;\n              map\n            }\n            case None ⇒ map.updated(event.item, new IntHolder(event.count))\n          }\n      }\n      self ! TopProducts(0, histogram.map(p ⇒ (p._1, p._2.value)))\n    }\n\n  var topProducts = Map.empty[ItemRef, Int]\n\n  def receive: PartialFunction[Any, Unit] = {\n    case GetTopProducts(id, replyTo) ⇒ replyTo ! TopProducts(id, topProducts)\n    case TopProducts(_, products) ⇒\n      topProducts = products\n      log.info(\"new {}\", products)\n  }\n}","title":"17.4 事件流模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"},{"location":"/extras.html","text":"","title":"额外指引 ·"},{"location":"/extras.html#额外指引","text":"Netty In Action In Scala","title":"额外指引"},{"location":"/errata.html","text":"","title":"勘误 ·"},{"location":"/errata.html#勘误","text":"TODO","title":"勘误"}]}